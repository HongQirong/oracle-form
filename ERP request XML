DECLARE
   p_table VARCHAR2(30) := UPPER('APPS.table');
   p_group_order VARCHAR2(4000) := UPPER('column1/column2,column3/column4');
   p_result VARCHAR2(1); --S是成功，E是錯誤
   p_error_msg VARCHAR2(4000);
   p_msg VARCHAR2(4000);

   TYPE l_vvt IS TABLE OF VARCHAR2(4000)
      INDEX BY VARCHAR2(4000);

   TYPE l_btt IS TABLE OF l_vvt --VARCHAR2(40)
      INDEX BY BINARY_INTEGER;

   TYPE l_bvt IS TABLE OF VARCHAR2(4000) --VARCHAR2(40)
      INDEX BY BINARY_INTEGER;

   TYPE l_bvtt IS TABLE OF l_bvt --VARCHAR2(40)
      INDEX BY BINARY_INTEGER;

   l_column_value_arr l_vvt;
   l_group_arr l_btt;
   l_next_group_flag_arr l_bvt;
   l_column_name_arr l_bvt;
   l_group_column_arr l_bvtt;
   l_row_num NUMBER := 0;

   l_query VARCHAR2(4000);
   l_dummy NUMBER;
   --TYPE column_map_type IS TABLE OF NUMBER INDEX BY VARCHAR2(32767);

   query2 VARCHAR2(32767);
   query3 VARCHAR2(32767);

   l_cursor INTEGER;
   l_description_table DBMS_SQL.desc_tab3;
   --l_mapping_table column_map_type;
   l_column_value VARCHAR2(4000);

   l_cursor_1 INTEGER;
   l_description_table_1 DBMS_SQL.desc_tab3;
   --l_mapping_table_1 column_map_type;
   l_column_value_1 VARCHAR2(4000);

   l_cursor_2 INTEGER;
   l_description_table_2 DBMS_SQL.desc_tab3;
   --l_mapping_table_2 column_map_type;
   l_column_value_2 VARCHAR2(4000);

   l_cursor_3 INTEGER;
   l_description_table_3 DBMS_SQL.desc_tab3;
   --l_mapping_table_3 column_map_type;
   l_column_value_3 VARCHAR2(4000);

   l_fetch_row NUMBER;
   v_error EXCEPTION; --本程式有錯， 拋例外統一處理錯誤訊息
   v_call_error EXCEPTION; --呼叫的程式拋出例外，且已有紀錄錯誤程式行
BEGIN
   DBMS_OUTPUT.enable(buffer_size => NULL);

   fnd_file.put_line(fnd_file.output
                    ,'<?xml version = ''1.0'' encoding = ''UTF-8''?>');
   fnd_file.new_line(fnd_file.output
                    ,1);
   fnd_file.put_line(fnd_file.output
                    ,'<MAIN>');
   fnd_file.new_line(fnd_file.output
                    ,1);
   DBMS_OUTPUT.put_line('<?xml version = ''1.0'' encoding = ''UTF-8''?>');
   DBMS_OUTPUT.put_line('<MAIN>');

   IF p_table IS NOT NULL
   THEN
      l_query := 'select * from '
                 || p_table
                 || ' order by ';

      SELECT l_query
             || REPLACE(p_group_order
                       ,'/'
                       ,',')
                st
        INTO l_query
        FROM DUAL;

      DBMS_OUTPUT.put_line('l_query = '
                           || l_query);
   END IF;

   --印參數
   IF (l_query IS NOT NULL)
   THEN
      l_cursor := DBMS_SQL.open_cursor;
      DBMS_SQL.parse(l_cursor
                    ,l_query
                    ,DBMS_SQL.native);
      DBMS_SQL.describe_columns3(l_cursor
                                ,l_dummy
                                ,l_description_table);

      FOR i IN 1 .. l_description_table.COUNT
      LOOP
         DBMS_SQL.define_column(l_cursor
                               ,i
                               ,l_column_value
                               ,4000);
      END LOOP;

      l_dummy := DBMS_SQL.execute(l_cursor);
      DBMS_OUTPUT.put_line('l_dummy = '
                           || l_dummy);
      DBMS_OUTPUT.put_line('p_group_order = '
                           || p_group_order);

      LOOP
         EXIT WHEN DBMS_SQL.fetch_rows(l_cursor) <= 0;
         l_row_num :=   l_row_num
                      + 1;

         FOR i IN 1 .. l_description_table.COUNT
         LOOP
            IF INSTR(TRANSLATE(','
                               || p_group_order
                               || ','
                              ,'/ '
                              ,',')
                    ,','
                     || l_description_table(i).col_name
                     || ',') = 0
            THEN
               CONTINUE;
            END IF;

            DBMS_SQL.COLUMN_VALUE(l_cursor
                                 ,i
                                 ,l_column_value);

            SELECT REPLACE(l_column_value
                          ,CHR(39)
                          ,CHR(38)
                           || 'apos;')
              INTO l_column_value
              FROM DUAL;

            SELECT REPLACE(l_column_value
                          ,'"'
                          ,CHR(38)
                           || 'quot;')
              INTO l_column_value
              FROM DUAL;

            SELECT REPLACE(l_column_value
                          ,CHR(38)
                          ,CHR(38)
                           || 'amp;')
              INTO l_column_value
              FROM DUAL;

            SELECT REPLACE(l_column_value
                          ,'<'
                          ,CHR(38)
                           || 'lt;')
              INTO l_column_value
              FROM DUAL;

            SELECT REPLACE(l_column_value
                          ,'>'
                          ,CHR(38)
                           || 'gt;')
              INTO l_column_value
              FROM DUAL;


            FOR r_group IN (    SELECT REGEXP_SUBSTR(st
                                                    ,'[^, ]+'
                                                    ,1
                                                    ,LEVEL)
                                          group_column
                                      ,ROWNUM group_seq
                                  FROM (SELECT p_group_order st FROM DUAL)
                            CONNECT BY REGEXP_SUBSTR(st
                                                    ,'[^, ]+'
                                                    ,1
                                                    ,LEVEL)
                                          IS NOT NULL) --用","分列
            LOOP
               FOR r_column IN (    SELECT REGEXP_SUBSTR(st
                                                        ,'[^/ ]+'
                                                        ,1
                                                        ,LEVEL)
                                              column_name
                                          ,ROWNUM column_seq
                                      FROM (SELECT r_group.group_column st FROM DUAL) --每一個群組取第一個"_"之後的字串
                                CONNECT BY REGEXP_SUBSTR(st
                                                        ,'[^/ ]+'
                                                        ,1
                                                        ,LEVEL)
                                              IS NOT NULL) --用"/"分列
               LOOP
                  IF r_column.column_name != l_description_table(i).col_name
                  THEN
                     CONTINUE;
                  END IF;

                  IF l_group_arr.EXISTS(r_group.group_seq)
                     AND l_group_arr(r_group.group_seq).EXISTS(r_column.column_name)
                     AND l_group_arr(r_group.group_seq)(r_column.column_name) = l_column_value
                  THEN
                     CONTINUE;
                  ELSE
                     l_column_value_arr(r_column.column_name) := l_column_value;
                     l_group_arr(r_group.group_seq) := l_column_value_arr;
                     l_next_group_flag_arr(r_group.group_seq) := 'Y';
                     --                     DBMS_OUTPUT.put_line('r_column.column_seq = '
                     --                                          || r_column.column_seq);
                     --                     DBMS_OUTPUT.put_line('r_column.column_name = '
                     --                                          || r_column.column_name);
                     --                     DBMS_OUTPUT.put_line('r_group.group_seq = '
                     --                                          || r_group.group_seq);

                     l_column_name_arr(r_column.column_seq) := r_column.column_name;
                     l_group_column_arr(r_group.group_seq) := l_column_name_arr;
                  END IF;
               END LOOP;
            END LOOP;
         --            DBMS_OUTPUT.put_line('l_group = '
         --                                 || l_group(1)('PAY_GROUP'));
         --            DBMS_OUTPUT.put_line('l_group = '
         --                                 || l_group(1)('DUE_DATE'));
         --            DBMS_OUTPUT.put_line('l_group = '
         --                                 || l_group(2)('VENDOR_ID'));
         --            DBMS_OUTPUT.put_line('l_group = '
         --                                 || l_group(2)('BATCH_NAME'));

         END LOOP;

         FOR r_g_seq IN 1 .. l_next_group_flag_arr.COUNT
         LOOP
            IF l_next_group_flag_arr.EXISTS(  r_g_seq
                                            - 1)
               AND l_next_group_flag_arr(  r_g_seq
                                         - 1) = 'Y'
            THEN
               l_next_group_flag_arr(r_g_seq) := 'Y';
            END IF;
         END LOOP;


         IF l_row_num > 1
         THEN
            FOR r_seq IN REVERSE 1 .. l_group_arr.COUNT
            LOOP
               IF l_next_group_flag_arr(r_seq) = 'N'
               THEN
                  CONTINUE;
               END IF;

               apps.fnd_file.put_line(apps.fnd_file.output
                                     ,'</G'
                                      || r_seq
                                      || '>');
               DBMS_OUTPUT.put_line('</G'
                                    || r_seq
                                    || '>');
            END LOOP;
         END IF;

         FOR r_g_seq IN 1 .. l_group_arr.COUNT
         LOOP
            IF l_next_group_flag_arr(r_g_seq) = 'N'
            THEN
               CONTINUE;
            END IF;

            apps.fnd_file.put_line(apps.fnd_file.output
                                  ,'<G'
                                   || r_g_seq
                                   || '>');
            DBMS_OUTPUT.put_line('<G'
                                 || r_g_seq
                                 || '>');

            FOR r_c_seq IN 1 .. l_group_column_arr(r_g_seq).COUNT
            LOOP
               fnd_file.put(fnd_file.output
                           ,'<'
                            || l_group_column_arr(r_g_seq)(r_c_seq)
                            || '>');

               fnd_file.put(fnd_file.output
                           ,l_group_arr(r_g_seq)(l_group_column_arr(r_g_seq)(r_c_seq)));
               fnd_file.put_line(fnd_file.output
                                ,'</'
                                 || l_group_column_arr(r_g_seq)(r_c_seq)
                                 || '>');
               DBMS_OUTPUT.put('<'
                               || l_group_column_arr(r_g_seq)(r_c_seq)
                               || '>');
               DBMS_OUTPUT.put(l_group_arr(r_g_seq)(l_group_column_arr(r_g_seq)(r_c_seq)));
               DBMS_OUTPUT.put_line('<'
                                    || l_group_column_arr(r_g_seq)(r_c_seq)
                                    || '>');
            END LOOP;

            l_next_group_flag_arr(r_g_seq) := 'N';
         END LOOP;

         FOR i IN 1 .. l_description_table.COUNT
         LOOP
            IF INSTR(TRANSLATE(p_group_order
                              ,'/ '
                              ,',')
                    ,','
                     || l_description_table(i).col_name
                     || ',') > 0
            THEN
               CONTINUE;
            END IF;

            DBMS_SQL.COLUMN_VALUE(l_cursor
                                 ,i
                                 ,l_column_value);

            SELECT REPLACE(l_column_value
                          ,CHR(39)
                          ,CHR(38)
                           || 'apos;')
              INTO l_column_value
              FROM DUAL;

            SELECT REPLACE(l_column_value
                          ,'"'
                          ,CHR(38)
                           || 'quot;')
              INTO l_column_value
              FROM DUAL;

            SELECT REPLACE(l_column_value
                          ,CHR(38)
                          ,CHR(38)
                           || 'amp;')
              INTO l_column_value
              FROM DUAL;

            SELECT REPLACE(l_column_value
                          ,'<'
                          ,CHR(38)
                           || 'lt;')
              INTO l_column_value
              FROM DUAL;

            SELECT REPLACE(l_column_value
                          ,'>'
                          ,CHR(38)
                           || 'gt;')
              INTO l_column_value
              FROM DUAL;

            IF i = 1
            THEN
               apps.fnd_file.put_line(apps.fnd_file.output
                                     ,'<G>');
               DBMS_OUTPUT.put_line('<G>');
            END IF;

            fnd_file.put(fnd_file.output
                        ,'<'
                         || l_description_table(i).col_name
                         || '>');
            fnd_file.put(fnd_file.output
                        ,l_column_value);
            fnd_file.put_line(fnd_file.output
                             ,'</'
                              || l_description_table(i).col_name
                              || '>');

            DBMS_OUTPUT.put('<'
                            || l_description_table(i).col_name
                            || '>');
            DBMS_OUTPUT.put(l_column_value);
            DBMS_OUTPUT.put_line('</'
                                 || l_description_table(i).col_name
                                 || '>');
         END LOOP;

         apps.fnd_file.put_line(apps.fnd_file.output
                               ,'</G>');
         DBMS_OUTPUT.put_line('</G>');
      END LOOP;

      FOR r_seq IN REVERSE 1 .. l_group_arr.COUNT
      LOOP
         apps.fnd_file.put_line(apps.fnd_file.output
                               ,'</G'
                                || r_seq
                                || '>');
         DBMS_OUTPUT.put_line('</G'
                              || r_seq
                              || '>');
      END LOOP;


      DBMS_SQL.close_cursor(l_cursor);
   END IF;

   DBMS_OUTPUT.put('<ERRMSG>');
   DBMS_OUTPUT.put('');
   DBMS_OUTPUT.put_line('</ERRMSG>');
   DBMS_OUTPUT.put_line('</MAIN>');
   fnd_file.put(fnd_file.output
               ,'<ERRMSG>');
   fnd_file.put(fnd_file.output
               ,'');
   fnd_file.put_line(fnd_file.output
                    ,'</ERRMSG>');
   fnd_file.new_line(fnd_file.output
                    ,1);
   fnd_file.put_line(fnd_file.output
                    ,'</MAIN>');
   fnd_file.new_line(fnd_file.output
                    ,1);
EXCEPTION
   WHEN v_call_error
   THEN
      p_result := 'E';
   WHEN v_error
   THEN
      p_result := 'E';
      p_error_msg := SUBSTR(p_error_msg
                            || CHR(10)
                            || '此次執行的程式:'
                            || CHR(10)
                            || DBMS_UTILITY.format_error_stack
                            || DBMS_UTILITY.format_error_backtrace
                            || DBMS_UTILITY.format_call_stack
                           ,1
                           ,600);
      fnd_file.put(fnd_file.output
                  ,'<ERRMSG>');
      fnd_file.put(fnd_file.output
                  ,p_error_msg);
      fnd_file.put_line(fnd_file.output
                       ,'</ERRMSG>');
      fnd_file.new_line(fnd_file.output
                       ,1);
      fnd_file.put_line(fnd_file.output
                       ,'</MAIN>');
      fnd_file.new_line(fnd_file.output
                       ,1);
      DBMS_OUTPUT.put('<ERRMSG>');
      DBMS_OUTPUT.put(p_error_msg);
      DBMS_OUTPUT.put_line('</ERRMSG>');
      DBMS_OUTPUT.put_line('</MAIN>');
   WHEN OTHERS
   THEN
      p_result := 'E';
      p_error_msg := SUBSTR(p_error_msg
                            || CHR(10)
                            || '此次執行的程式:'
                            || CHR(10)
                            || DBMS_UTILITY.format_error_stack
                            || DBMS_UTILITY.format_error_backtrace
                            || DBMS_UTILITY.format_call_stack
                           ,1
                           ,600);
      fnd_file.put(fnd_file.output
                  ,'<ERRMSG>');
      fnd_file.put(fnd_file.output
                  ,p_error_msg);
      fnd_file.put_line(fnd_file.output
                       ,'</ERRMSG>');
      fnd_file.new_line(fnd_file.output
                       ,1);
      fnd_file.put_line(fnd_file.output
                       ,'</MAIN>');
      fnd_file.new_line(fnd_file.output
                       ,1);
      DBMS_OUTPUT.put('<ERRMSG>');
      DBMS_OUTPUT.put(p_error_msg);
      DBMS_OUTPUT.put_line('</ERRMSG>');
      DBMS_OUTPUT.put_line('</MAIN>');
END;
/
------------------------------------------------------------------
/*
<?for-each-group: G_1;./C1_SHEET_NAME?><?spreadsheet-sheet-name:{C1_SHEET_NAME}?> <?if:C1_SHEET_NAME ='報表A'?>
報表A
COLUMN1	COLUMN2	COLUMN3
<?for-each:G_2?> <?COLUMN1?> <?COLUMN2?> <?COLUMN3?> <?end for-each?>

<?end if?><?if:C1_SHEET_NAME ='報表B'?>
報表B
COLUMN1	COLUMN2	COLUMN3
<?for-each:G_2?> <?COLUMN1?> <?COLUMN2?> <?COLUMN3?> <?end for-each?>

<?end if?>
<?split-by-page-break:?><?end for-each-group?>
*/
----------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE XXMULTISHEET(RET_MSG OUT VARCHAR2
                                         ,RET_CODE OUT VARCHAR2) IS

 sqlp varchar2(1000);
 sql1 varchar2(1000);
 sql2 varchar2(1000);
 sql3 varchar2(1000);
BEGIN
sqlp := '';
sql1 := '';
sql2 := '';
sql3 := '';


sql1 := '
    select ''報表A'' as C1_SHEET_NAME from dual
    UNION
    select ''報表B'' as C1_SHEET_NAME from dual
';

sql2 := '
select * from (
select ''報表A'' as SHEET_NAME
, ''AAA1'' as COLUMNA1
, ''BBB1'' as COLUMNA2
, ''CCC1'' as COLUMNA3 from dual
UNION
select ''報表B'' as SHEET_NAME
, ''AAA3'' as COLUMNB1
, ''BBB3'' as COLUMNB2
, ''CCC3'' as COLUMNB3 from dual
)
where SHEET_NAME = ''C1_SHEET_NAME''
';



XXFND_XMLCREATOR_SP(sqlp,sql1, sql2, sql3);




EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
END XXJBHOMEWORK2;
/
CREATE OR REPLACE PROCEDURE APPS.XXFND_XMLCREATOR_SP(p_query IN VARCHAR2
                                            ,p_query1 IN VARCHAR2
                                            ,p_query2 IN VARCHAR2
                                            ,p_query3 IN VARCHAR2) IS

    l_dummy             NUMBER;
    --TYPE column_map_type IS TABLE OF NUMBER INDEX BY VARCHAR2(32767);

    query2            VARCHAR2(32767);
    query3            VARCHAR2(32767);

    l_cursor           INTEGER;
    l_description_table dbms_sql.desc_tab3;
    --l_mapping_table column_map_type;
    l_column_value  VARCHAR2(4000);

    l_cursor_1           INTEGER;
    l_description_table_1 dbms_sql.desc_tab3;
    --l_mapping_table_1 column_map_type;
    l_column_value_1  VARCHAR2(4000);

    l_cursor_2           INTEGER;
    l_description_table_2 dbms_sql.desc_tab3;
    --l_mapping_table_2 column_map_type;
    l_column_value_2  VARCHAR2(4000);

    l_cursor_3           INTEGER;
    l_description_table_3 dbms_sql.desc_tab3;
    --l_mapping_table_3 column_map_type;
    l_column_value_3  VARCHAR2(4000);

    l_injection_error          EXCEPTION;
    l_noPara_error          EXCEPTION;

BEGIN
    DBMS_OUTPUT.ENABLE(buffer_size=>null);

    fnd_file.put_line(fnd_file.output, '<?xml version = ''1.0'' encoding = ''UTF-8''?>');
    fnd_file.new_line(fnd_file.output,1);
    fnd_file.put_line(fnd_file.output, '<MAIN>');
    fnd_file.new_line(fnd_file.output,1);
    dbms_output.put_line('<?xml version = ''1.0'' encoding = ''UTF-8''?>');
    dbms_output.put_line('<MAIN>');

    --印參數
    IF (p_query IS NOT NULL) THEN
      --RAISE l_noPara_error;
    --ELSE
        l_cursor := dbms_sql.open_cursor;
        dbms_sql.parse(l_cursor, p_query, dbms_sql.native);
        dbms_sql.describe_columns3(l_cursor, l_dummy, l_description_table);
        FOR i IN 1 .. l_description_table.count LOOP
                  --    l_mapping_table(l_description_table(i).col_name) := i;
            dbms_sql.define_column(l_cursor, i, l_column_value, 4000);
        END LOOP;
        l_dummy := dbms_sql.execute(l_cursor);
        LOOP
            EXIT WHEN dbms_sql.fetch_rows(l_cursor) <= 0;

            FOR i IN 1 .. l_description_table.count LOOP
                --dbms_sql.column_value(l_cursor, l_mapping_table(l_description_table(i).col_name), l_column_value);
                IF NOT regexp_like(l_column_value,'^[^:=;\'']+$')
                OR REGEXP_INSTR(l_column_value,'--',1) >= 1
                OR REGEXP_INSTR(UPPER(l_column_value),'SELECT',1) >= 1
                OR REGEXP_INSTR(UPPER(l_column_value),'INSERT',1) >= 1
                OR REGEXP_INSTR(UPPER(l_column_value),'UPDATE',1) >= 1
                OR REGEXP_INSTR(UPPER(l_column_value),'DELETE',1) >= 1
                OR REGEXP_INSTR(UPPER(l_column_value),'DROP',1) >= 1
                OR REGEXP_INSTR(UPPER(l_column_value),'CREATE',1) >= 1
                THEN
                  RAISE l_injection_error;
                END IF;
                                
                dbms_sql.column_value(l_cursor, i, l_column_value);

                fnd_file.put(fnd_file.output, '<'||l_description_table(i).col_name||'>');
                fnd_file.put(fnd_file.output, l_column_value);
                fnd_file.put_line(fnd_file.output, '</'||l_description_table(i).col_name||'>');

                dbms_output.put('<'||l_description_table(i).col_name||'>');
                dbms_output.put(l_column_value);
                dbms_output.put_line('</'||l_description_table(i).col_name||'>');

            END LOOP;
        END LOOP;
        dbms_sql.close_cursor(l_cursor);
    END IF;

    l_cursor_1 := dbms_sql.open_cursor;
    dbms_sql.parse(l_cursor_1, p_query1, dbms_sql.native);
    dbms_sql.describe_columns3(l_cursor_1, l_dummy, l_description_table_1);
    FOR i IN 1 .. l_description_table_1.count LOOP
        --l_mapping_table_1(l_description_table_1(i).col_name) := i;
        dbms_sql.define_column(l_cursor_1, i, l_column_value_1, 4000);
    END LOOP;
    l_dummy := dbms_sql.execute(l_cursor_1);
    LOOP
        EXIT WHEN dbms_sql.fetch_rows(l_cursor_1) <= 0;

        query2 := p_query2;

        fnd_file.put_line(fnd_file.output, '<G_1>');
        fnd_file.new_line(fnd_file.output,1);
        dbms_output.put_line('<G_1>');
        --產生query1的欄位資料
        FOR i IN 1 .. l_description_table_1.count LOOP
            --dbms_sql.column_value(l_cursor_1, l_mapping_table_1(l_description_table_1(i).col_name), l_column_value_1);
            
            dbms_sql.column_value(l_cursor_1, i, l_column_value_1);
            fnd_file.put(fnd_file.output, '<'||l_description_table_1(i).col_name||'>');
            fnd_file.put(fnd_file.output, replace(l_column_value_1, '&', '＆'));
            fnd_file.put_line(fnd_file.output, '</'||l_description_table_1(i).col_name||'>');

            dbms_output.put('<'||l_description_table_1(i).col_name||'>');
            dbms_output.put(replace(l_column_value_1, '&', '＆'));
            dbms_output.put_line('</'||l_description_table_1(i).col_name||'>');

            --把query1的參數傳到query2
            IF NOT(query2 IS NULL) THEN
                IF INSTR(query2, 'C1_') > 0 AND INSTR(l_description_table_1(i).col_name, 'C1_') > 0 THEN
                    query2 := replace(query2, l_description_table_1(i).col_name, l_column_value_1);
                END IF;
            END IF;
        END LOOP;

        IF NOT(query2 IS NULL) THEN
            l_cursor_2 := dbms_sql.open_cursor;
            dbms_sql.parse(l_cursor_2, query2, dbms_sql.native);
            dbms_sql.describe_columns3(l_cursor_2, l_dummy, l_description_table_2);
            FOR j IN 1 .. l_description_table_2.count LOOP
                --l_mapping_table_2(l_description_table_2(j).col_name) := j;
                dbms_sql.define_column(l_cursor_2, j, l_column_value_2, 4000);
            END LOOP;
            l_dummy := dbms_sql.execute(l_cursor_2);

            LOOP
                EXIT WHEN dbms_sql.fetch_rows(l_cursor_2) <= 0;

                query3 := p_query3;

                fnd_file.put_line(fnd_file.output, '<G_2>');
                fnd_file.new_line(fnd_file.output,1);
                dbms_output.put_line('<G_2>');
                FOR i IN 1 .. l_description_table_1.count LOOP
                    --dbms_sql.column_value(l_cursor_1, l_mapping_table_1(l_description_table_1(i).col_name), l_column_value_1);
                    dbms_sql.column_value(l_cursor_1, i, l_column_value_1);

                    --把query1的參數傳到query3
                    IF NOT(query3 IS NULL) THEN
                        IF INSTR(query3, 'C1_') > 0 AND INSTR(l_description_table_1(i).col_name, 'C1_') > 0 THEN
                            query3 := replace(query3, l_description_table_1(i).col_name, l_column_value_1);
                        END IF;
                    END IF;
                END LOOP;
                FOR j IN 1 .. l_description_table_2.count LOOP
                    --dbms_sql.column_value(l_cursor_2, l_mapping_table_2(l_description_table_2(j).col_name), l_column_value_2);
                    dbms_sql.column_value(l_cursor_2, j, l_column_value_2);

                    fnd_file.put(fnd_file.output, '<'||l_description_table_2(j).col_name||'>');
                    fnd_file.put(fnd_file.output, replace(l_column_value_2, '&', '＆'));
                    fnd_file.put_line(fnd_file.output, '</'||l_description_table_2(j).col_name||'>');

                    dbms_output.put('<'||l_description_table_2(j).col_name||'>');
                    dbms_output.put(replace(l_column_value_2, '&', '＆'));
                    dbms_output.put_line('</'||l_description_table_2(j).col_name||'>');

                    --把query2的參數傳到query3
                    IF NOT(query3 IS NULL) THEN
                        IF INSTR(query3, 'C2_') > 0 AND INSTR(l_description_table_2(j).col_name, 'C2_') > 0 THEN
                            query3 := replace(query3, l_description_table_2(j).col_name, l_column_value_2);
                        END IF;
                    END IF;
                END LOOP;


                IF NOT(query3 IS NULL) THEN
                    l_cursor_3 := dbms_sql.open_cursor;
                    dbms_sql.parse(l_cursor_3, query3, dbms_sql.native);
                    dbms_sql.describe_columns3(l_cursor_3, l_dummy, l_description_table_3);
                    FOR k IN 1 .. l_description_table_3.count LOOP
                        --l_mapping_table_3(l_description_table_3(k).col_name) := k;
                        dbms_sql.define_column(l_cursor_3, k, l_column_value_3, 4000);
                    END LOOP;
                    l_dummy := dbms_sql.execute(l_cursor_3);
                    LOOP
                        EXIT WHEN dbms_sql.fetch_rows(l_cursor_3) <= 0;

                        fnd_file.put_line(fnd_file.output, '<G_3>');
                        fnd_file.new_line(fnd_file.output,1);
                        dbms_output.put_line('<G_3>');
                        FOR k IN 1 .. l_description_table_3.count LOOP
                            --dbms_sql.column_value(l_cursor_3, l_mapping_table_3(l_description_table_3(k).col_name), l_column_value_3);
                            dbms_sql.column_value(l_cursor_3, k, l_column_value_3);

                            fnd_file.put(fnd_file.output, '<'||l_description_table_3(k).col_name||'>');
                            fnd_file.put(fnd_file.output, replace(l_column_value_3, '&', '＆'));
                            fnd_file.put_line(fnd_file.output, '</'||l_description_table_3(k).col_name||'>');

                            dbms_output.put('<'||l_description_table_3(k).col_name||'>');
                            dbms_output.put(replace(l_column_value_3, '&', '＆'));
                            dbms_output.put_line('</'||l_description_table_3(k).col_name||'>');
                        END LOOP;
                        fnd_file.put_line(fnd_file.output, '</G_3>');
                        fnd_file.new_line(fnd_file.output,1);
                        dbms_output.put_line('</G_3>');
                    END LOOP;
                    dbms_sql.close_cursor(l_cursor_3);
                END IF;
                fnd_file.put_line(fnd_file.output, '</G_2>');
                fnd_file.new_line(fnd_file.output,1);
                dbms_output.put_line('</G_2>');
            END LOOP;
            dbms_sql.close_cursor(l_cursor_2);
        END IF;
        fnd_file.put_line(fnd_file.output, '</G_1>');
        fnd_file.new_line(fnd_file.output,1);
        dbms_output.put_line('</G_1>');
    END LOOP;
    dbms_sql.close_cursor(l_cursor_1);

    dbms_output.put('<ERRMSG>');
    dbms_output.put('');
    dbms_output.put_line('</ERRMSG>');
    dbms_output.put_line('</MAIN>');
    fnd_file.put(fnd_file.output, '<ERRMSG>');
    fnd_file.put(fnd_file.output, '');
    fnd_file.put_line(fnd_file.output, '</ERRMSG>');
    fnd_file.new_line(fnd_file.output,1);
    fnd_file.put_line(fnd_file.output, '</MAIN>');
    fnd_file.new_line(fnd_file.output,1);

EXCEPTION
  WHEN l_injection_error THEN
        dbms_output.put('<ERRMSG>');
        dbms_output.put('SQL Injection Error');
        dbms_output.put_line('</ERRMSG>');
        dbms_output.put_line('</MAIN>');
        fnd_file.put(fnd_file.output, '<ERRMSG>');
        fnd_file.put(fnd_file.output, 'SQL Injection Error');
        fnd_file.put_line(fnd_file.output, '</ERRMSG>');
        fnd_file.new_line(fnd_file.output,1);
        fnd_file.put_line(fnd_file.output, '</MAIN>');
        fnd_file.new_line(fnd_file.output,1);
  WHEN l_noPara_error THEN
        dbms_output.put('<ERRMSG>');
        dbms_output.put('Parameter SQL Required(sqlp)');
        dbms_output.put_line('</ERRMSG>');
        dbms_output.put_line('</MAIN>');
        fnd_file.put(fnd_file.output, '<ERRMSG>');
        fnd_file.put(fnd_file.output, 'SQL Injection Error');
        fnd_file.put_line(fnd_file.output, '</ERRMSG>');
        fnd_file.new_line(fnd_file.output,1);
        fnd_file.put_line(fnd_file.output, '</MAIN>');
        fnd_file.new_line(fnd_file.output,1);
    WHEN OTHERS THEN
        fnd_file.put(fnd_file.output, '<ERRMSG>');
        fnd_file.put(fnd_file.output, 'Region not present '||sqlerrm);
        fnd_file.put_line(fnd_file.output, '</ERRMSG>');
        fnd_file.new_line(fnd_file.output,1);
        fnd_file.put_line(fnd_file.output, '</MAIN>');
        fnd_file.new_line(fnd_file.output,1);
        dbms_output.put('<ERRMSG>');
        dbms_output.put('Region not present '||sqlerrm);
        dbms_output.put_line('</ERRMSG>');
        dbms_output.put_line('</MAIN>');
    ROLLBACK;

END XXFND_XMLCREATOR_SP;
/
CREATE OR REPLACE PACKAGE BODY apps.xxapry008_pkg
IS
   -------------------------------------------------------------------------------------
   --月結總表給號程式
   PROCEDURE generate_total_seq(p_period_ym IN VARCHAR2)
   AS
      CURSOR c
      IS
           SELECT aia.org_id
                 ,av.vendor_id
                 ,aia.vendor_site_id
                 ,aia.invoice_id
                 ,aia.invoice_type_lookup_code
                 ,av.vendor_name
                 ,aia.invoice_num
             FROM ap_suppliers av
                 ,ap_invoices_all aia
                 ,ap_batches_all aba
            WHERE 1 = 1
                  AND av.vendor_id = aia.vendor_id
                  AND aia.batch_id = aba.batch_id(+)
                  AND NVL(aia.attribute14, 'X') = 'Y'
                  AND TO_CHAR(aia.gl_date
                             ,'RRRRMM') = p_period_ym
                  AND aia.org_id IN (SELECT hou.organization_id
                                       FROM hr_operating_units hou
                                      WHERE hou.set_of_books_id = 2022)
                  AND aia.pay_group_lookup_code IN (SELECT flv.lookup_code
                                                      FROM fnd_lookup_values flv
                                                     WHERE 1 = 1
                                                           AND flv.lookup_type = 'PAY GROUP'
                                                           AND flv.language = 'ZHT'
                                                           AND (flv.description LIKE '%台北月結%'))
         /*
         AND AIA.PAY_GROUP_LOOKUP_CODE NOT IN
             (SELECT FLV.LOOKUP_CODE
                FROM FND_LOOKUP_VALUES FLV
               WHERE 1 = 1
                 AND FLV.LOOKUP_TYPE = 'PAY GROUP'
                 AND FLV.LANGUAGE = 'ZHT'
                 AND (FLV.DESCRIPTION LIKE '%國內採購%' OR FLV.DESCRIPTION LIKE '%不定期付款%')
             )
         AND AIA.BATCH_ID IN
             (SELECT BATCH_ID
                FROM (SELECT ABA.BATCH_ID
                            ,AIA1.PAY_GROUP_LOOKUP_CODE
                        FROM AP_BATCHES_ALL  ABA
                            ,AP_INVOICES_ALL AIA1
                       WHERE ABA.BATCH_ID(+) = AIA1.BATCH_ID
                         AND TO_CHAR(AIA1.GL_DATE, 'RRRRMM') = P_PERIOD_YM
                       GROUP BY ABA.BATCH_ID
                               ,AIA1.PAY_GROUP_LOOKUP_CODE)
              HAVING COUNT(*) > 1
               GROUP BY BATCH_ID)
       */
         ORDER BY av.vendor_name
                 ,aba.batch_name
                 ,aia.pay_group_lookup_code
                 ,aia.invoice_num
                 ,(SELECT NVL(SUM(  t.invoice_amount
                                  * NVL(t.exchange_rate, 1))
                             ,0)
                     FROM ap_invoices_all t
                    WHERE t.org_id = aba.org_id
                          AND t.batch_id = aba.batch_id
                          AND NVL(aia.attribute14, 'X') = 'Y'
                          AND TO_CHAR(aia.gl_date
                                     ,'RRRRMM') = p_period_ym) DESC;

      l_period_ym VARCHAR2(10);
      l_batch_num NUMBER := 0;
      l_detail_num NUMBER := 0;
   BEGIN
      --updae invoice attribute15 null
      UPDATE ap_invoices_all t
         SET t.attribute15 = NULL
       WHERE TO_CHAR(t.gl_date
                    ,'RRRRMM') = p_period_ym;

      COMMIT;

      --UPDATE BATCH INVOICE
      FOR lc IN c
      LOOP
         l_batch_num :=   l_batch_num
                        + 1;

         UPDATE ap_invoices_all aia
            SET aia.attribute15 = l_batch_num
          WHERE aia.org_id = lc.org_id
                AND aia.vendor_id = lc.vendor_id
                AND aia.vendor_site_id = lc.vendor_site_id
                AND aia.invoice_type_lookup_code = lc.invoice_type_lookup_code
                AND aia.invoice_id = lc.invoice_id;

         --dbms_output.put_line(LC.INVOICE_ID);
         COMMIT;
      END LOOP;
   END generate_total_seq;

   -------------------------------------------------------------------------------------
   PROCEDURE main(errbuf                 OUT VARCHAR2
                 ,retcode                OUT VARCHAR2
                 ,p_org_id            IN     NUMBER
                 ,p_user_id           IN     NUMBER
                 ,p_batch_name        IN     VARCHAR2
                 ,p_monthly_cycle     IN     VARCHAR2
                 ,p_pay_group_code_fm IN     VARCHAR2
                 ,p_pay_group_code_to IN     VARCHAR2
                 ,p_period_name       IN     VARCHAR2
                 ,p_payment_method    IN     VARCHAR2
                 ,p_due_date          IN     VARCHAR2
                 ,p_page_group        IN     VARCHAR2 --'PAY_GROUP_PERIOD_NAME_DUE_DATE'表示依付款群組、應付帳款期間、排定付款日期同頁
                                                     )
   IS
      i NUMBER := 1;
      j NUMBER := 1;
      k NUMBER := 1;
      v_user VARCHAR2(30);
      v_gl_date_fm DATE;
      v_gl_date_to DATE;
      v_registration_num VARCHAR2(10) := '';
      v_page_group VARCHAR2(32767);
      v_error EXCEPTION;
      v_call_error EXCEPTION;
   BEGIN
      --Mo_Global.init ('SQLAP');
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_LANGUAGE = ''AMERICAN''';

      SELECT gps.start_date
            ,gps.end_date
        INTO v_gl_date_fm
            ,v_gl_date_to
        FROM gl_period_statuses gps
       WHERE 1 = 1
             AND gps.ledger_id IN (SELECT hou.set_of_books_id
                                     FROM hr_operating_units hou
                                    WHERE hou.organization_id = p_org_id)
             AND gps.period_name = p_period_name
             AND gps.application_id IN (SELECT fa.application_id
                                          FROM fnd_application fa
                                         WHERE fa.application_short_name = 'SQLAP');

      xxapry008_pkg.generate_total_seq(TO_CHAR(v_gl_date_fm
                                              ,'RRRRMM'));

      SELECT description
        INTO v_user
        FROM fnd_user
       WHERE user_id = p_user_id;

      apps.fnd_file.put_line(apps.fnd_file.LOG
                            ,'--------------------');
      apps.fnd_file.put_line(apps.fnd_file.LOG
                            ,'P_ORG_ID='''
                             || p_org_id
                             || '''');
      apps.fnd_file.put_line(apps.fnd_file.LOG
                            ,'P_USER_ID='''
                             || p_user_id
                             || '''');
      apps.fnd_file.put_line(apps.fnd_file.LOG
                            ,'P_BATCH_NAME='''
                             || p_batch_name
                             || '''');
      apps.fnd_file.put_line(apps.fnd_file.LOG
                            ,'P_PAY_GROUP_CODE_FMD='''
                             || p_pay_group_code_fm
                             || '''');
      apps.fnd_file.put_line(apps.fnd_file.LOG
                            ,'P_PAY_GROUP_CODE_TO='''
                             || p_pay_group_code_to
                             || '''');
      apps.fnd_file.put_line(apps.fnd_file.LOG
                            ,'P_PERIOD_NAME='''
                             || p_period_name
                             || '''');
      apps.fnd_file.put_line(apps.fnd_file.LOG
                            ,'P_MONTHLY_CYCLE='''
                             || p_monthly_cycle
                             || '''');
      apps.fnd_file.put_line(apps.fnd_file.LOG
                            ,'P_PAYMENT_METHOD='''
                             || p_payment_method
                             || '''');
      apps.fnd_file.put_line(apps.fnd_file.LOG
                            ,'---------------------');
      apps.fnd_file.put_line(apps.fnd_file.LOG
                            ,fnd_profile.VALUE('ICX_CLIENT_IANA_ENCODING'));

      --apps.FND_FILE.put_line(apps.fnd_file.OUTPUT,'<?xml version="1.0" encoding="'||fnd_profile.value('ICX_CLIENT_IANA_ENCODING')||'"?>');
      --apps.FND_FILE.put_line(apps.fnd_file.OUTPUT,'<?xml version="1.0" encoding="BIG5"?>');
      apps.fnd_file.put_line(apps.fnd_file.output
                            ,'<?xml version="1.0"?>');
      apps.fnd_file.put_line(apps.fnd_file.output
                            ,'<ROWSET>');
      apps.fnd_file.put_line(apps.fnd_file.output
                            ,'<REPORT_NAME>XXAPRY008</REPORT_NAME>');


      FOR c_ap IN (  SELECT aia.org_id
                           ,aba.batch_name
                           ,aia.invoice_id
                           ,aia.vendor_id
                           ,av.vendor_name
                           ,aia.invoice_num
                           ,DECODE(aps.payment_method_code, 'CHECK', '', ibybnk.masked_bank_account_num) bank_account_num
                           ,DECODE(aps.payment_method_code
                                  ,'CHECK', ''
                                  ,(cbb.bank_name
                                    || cbb.bank_branch_name))
                               bank_account_name
                           ,  NVL((SELECT SUM(NVL(ail.amount, 0))
                                     FROM ap_invoice_lines_all ail
                                    WHERE ail.invoice_id = aia.invoice_id
                                          AND ail.line_type_lookup_code <> 'PREPAY')
                                 ,0)
                            - NVL(ap_invoices_utility_pkg.get_prepay_amount_applied(aia.invoice_id), 0)
                               invoice_amount
                           ,CASE
                               WHEN ROW_NUMBER()
                                       OVER(PARTITION BY aia.pay_group_lookup_code
                                                        ,av.vendor_name
                                                        ,TO_CHAR(aps.due_date
                                                                ,'YYYYMMDD')
                                            ORDER BY
                                               aia.pay_group_lookup_code
                                              ,av.vendor_name
                                              ,TO_CHAR(aps.due_date
                                                      ,'YYYYMMDD')
                                              ,aba.batch_name
                                              ,aia.invoice_num) = 1
                               THEN
                                  SUM(  NVL(ap_invoices_utility_pkg.get_line_total(aia.invoice_id), 0)
                                      - NVL(ap_invoices_pkg.get_amount_withheld(aia.invoice_id), 0)
                                      - NVL(ap_prepay_utils_pkg.get_prepaid_amount(aia.invoice_id), 0))
                                  OVER(PARTITION BY aia.pay_group_lookup_code
                                                   ,av.vendor_name
                                                   ,TO_CHAR(aps.due_date
                                                           ,'YYYYMMDD'))
                            END
                               invoice_sum
                           ,(SELECT NVL(SUM(aid.amount), 0)
                               FROM ap_invoice_distributions_all aid
                                   ,gl_code_combinations gcc
                              WHERE aid.dist_code_combination_id = gcc.code_combination_id
                                    AND aia.org_id = aia.org_id
                                    AND aia.invoice_id = aid.invoice_id
                                    AND gcc.segment3 = '119071')
                               tax_amount
                           ,at.name terms_name
                           ,aia.pay_group_lookup_code
                            || '-'
                            || flv.meaning
                               pay_group
                           ,TO_CHAR(aps.due_date
                                   ,'YYYY/MM/DD')
                               due_date
                           ,aps.payment_method_code
                           ,ipm.payment_method_name
                           ,DECODE(NVL(aia.attribute15, 'XXX')
                                  ,'XXX', ''
                                  ,'批次'
                                   || aia.attribute15)
                               total_seq
                           ,DECODE(p_page_group --p_page_group --'PAY_GROUP_PERIOD_NAME_DUE_DATE'
                                  ,'PAY_GROUP_PERIOD_NAME_DUE_DATE', aia.pay_group_lookup_code
                                                                     || '-'
                                                                     || flv.meaning
                                                                     || CHR(10)
                                                                     || '排定付款日'
                                                                     || TO_CHAR(aps.due_date
                                                                               ,'YYYY/MM/DD')
                                  ,aia.pay_group_lookup_code
                                   || '-'
                                   || flv.meaning)
                               page_group
                           ,aia.pay_group_lookup_code
                       FROM ap_batches_all aba
                           ,ap_invoices_all aia
                           ,ap_payment_schedules_all aps
                           ,ap_suppliers av
                           ,ap_terms_vl at
                           ,fnd_lookup_values flv
                           ,iby_ext_bank_accounts ibybnk
                           ,ce_bank_branches_v cbb
                           ,iby_payment_methods_tl ipm
                      WHERE aba.batch_id(+) = aia.batch_id
                            AND aia.invoice_id = aps.invoice_id
                            AND aps.payment_method_code = ipm.payment_method_code
                            AND ipm.language = 'ZHT'
                            AND aia.vendor_id = av.vendor_id(+)
                            AND aia.external_bank_account_id = ibybnk.ext_bank_account_id(+)
                            AND cbb.branch_party_id(+) = ibybnk.branch_id
                            AND cbb.bank_party_id(+) = ibybnk.bank_id
                            AND aia.terms_id = at.term_id(+)
                            AND aia.pay_group_lookup_code = flv.lookup_code(+)
                            AND flv.lookup_type = 'PAY GROUP'
                            AND flv.language = 'ZHT'
                            AND ap_invoices_pkg.get_approval_status(aia.invoice_id
                                                                   ,aia.invoice_amount
                                                                   ,aia.payment_status_flag
                                                                   ,aia.invoice_type_lookup_code) IN ('APPROVED'
                                                                                                     ,'UNPAID')
                            AND aia.org_id = p_org_id --87 -- p_org_id --87
                            AND TO_CHAR(aia.gl_date
                                       ,'MON-YY') = p_period_name -- 'MAY-23' -- p_period_name -- 'MAY-23'
                            AND aba.batch_name = NVL(p_batch_name, aba.batch_name)
                            AND TO_CHAR(aps.due_date
                                       ,'YYYY/MM/DD') = NVL(p_due_date
                                                           ,TO_CHAR(aps.due_date
                                                                   ,'YYYY/MM/DD'))
                            AND (aia.pay_group_lookup_code BETWEEN p_pay_group_code_fm AND p_pay_group_code_to
                                 OR p_pay_group_code_fm IS NULL
                                 OR p_pay_group_code_to IS NULL)
                            AND flv.meaning LIKE
                                   '%'
                                   || p_monthly_cycle
                            AND flv.meaning NOT LIKE
                                   '%'
                                   || DECODE(p_monthly_cycle, '月結', '半月結', 'NULL')
                            AND aps.payment_method_code = NVL(p_payment_method, aps.payment_method_code)
                   --AND AIA.GL_DATE >= TO_DATE('20170301','YYYYMMDD')
                   ORDER BY page_group
                           ,av.vendor_name
                           ,aps.due_date
                           ,aba.batch_name
                           ,aia.invoice_num)
      LOOP
         IF v_page_group IS NOT NULL
            AND v_page_group != c_ap.page_group
         THEN
            apps.fnd_file.put_line(apps.fnd_file.output
                                  ,'</G_PAY_GROUP>');
         END IF;

         IF v_page_group IS NULL
            OR v_page_group != c_ap.page_group
         THEN
            apps.fnd_file.put_line(apps.fnd_file.output
                                  ,'<G_PAY_GROUP number="'
                                   || j
                                   || '">');

            apps.fnd_file.put_line(apps.fnd_file.output
                                  ,'  <PAGE_GROUP>'
                                   || c_ap.page_group
                                   || '</PAGE_GROUP>');

            apps.fnd_file.put_line(apps.fnd_file.output
                                  ,'  <USER>'
                                   || v_user
                                   || '</USER>');
            apps.fnd_file.put_line(apps.fnd_file.output
                                  ,'  <PERIOD_NAME>'
                                   || p_period_name
                                   || '</PERIOD_NAME>');
            v_page_group := c_ap.page_group;
            j :=   j
                 + 1;
            k := 1;
         END IF;


         apps.fnd_file.put_line(apps.fnd_file.output
                               ,'  <G_BATCH_NAME num="'
                                || i
                                || '">');
         apps.fnd_file.put_line(apps.fnd_file.output
                               ,'    <BATCH_NAME>'
                                || xxfnd_utility_pkg.replace_for_xml(c_ap.batch_name)
                                || '</BATCH_NAME>');
         apps.fnd_file.put_line(apps.fnd_file.output
                               ,'    <INVOICE_AMOUNT>'
                                || c_ap.invoice_amount
                                || '</INVOICE_AMOUNT>');
         apps.fnd_file.put_line(apps.fnd_file.output
                               ,'    <INVOICE_ID>'
                                || c_ap.invoice_id
                                || '</INVOICE_ID>');
         apps.fnd_file.put_line(apps.fnd_file.output
                               ,'    <INVOICE_NUM>'
                                || xxfnd_utility_pkg.replace_for_xml(c_ap.invoice_num)
                                || '</INVOICE_NUM>');
         apps.fnd_file.put_line(apps.fnd_file.output
                               ,'    <ORG_ID>'
                                || c_ap.org_id
                                || '</ORG_ID>');
         apps.fnd_file.put_line(apps.fnd_file.output
                               ,'    <BANK_ACCOUNT_NUM>'
                                || c_ap.bank_account_num
                                || '</BANK_ACCOUNT_NUM>');
         apps.fnd_file.put_line(apps.fnd_file.output
                               ,'    <BANK_ACCOUNT_NAME>'
                                || c_ap.bank_account_name
                                || '</BANK_ACCOUNT_NAME>');
         apps.fnd_file.put_line(apps.fnd_file.output
                               ,'    <SEQ>'
                                || i
                                || '</SEQ>');
         apps.fnd_file.put_line(apps.fnd_file.output
                               ,'    <TAX_AMOUNT>'
                                || c_ap.tax_amount
                                || '</TAX_AMOUNT>');
         apps.fnd_file.put_line(apps.fnd_file.output
                               ,'    <TERMS_NAME>'
                                || c_ap.terms_name
                                || '</TERMS_NAME>');



         IF NVL(c_ap.total_seq, 'XXX') = 'XXX'
         THEN
            apps.fnd_file.put_line(apps.fnd_file.output
                                  ,'    <TOTAL_SEQ>'
                                   || k
                                   || '</TOTAL_SEQ>');
         ELSE
            apps.fnd_file.put_line(apps.fnd_file.output
                                  ,'    <TOTAL_SEQ>'
                                   || c_ap.total_seq
                                   || '</TOTAL_SEQ>');
         END IF;

         apps.fnd_file.put_line(apps.fnd_file.output
                               ,'    <INVOICE_SUM>'
                                || c_ap.invoice_sum
                                || '</INVOICE_SUM>');

         BEGIN
            SELECT DECODE(LENGTH(h.vat_registration_num), 8, h.vat_registration_num, '')
              INTO v_registration_num
              FROM po_vendors h
             WHERE 1 = 1
                   AND h.vendor_id = c_ap.vendor_id;
         EXCEPTION
            WHEN OTHERS
            THEN
               v_registration_num := '';
         END;

         apps.fnd_file.put_line(apps.fnd_file.output
                               ,'    <VENDOR_NAME>'
                                || xxfnd_utility_pkg.replace_for_xml(c_ap.vendor_name)
                                || '</VENDOR_NAME>');
         apps.fnd_file.put_line(apps.fnd_file.output
                               ,'    <REGISTRATION_NUM>'
                                || v_registration_num
                                || '</REGISTRATION_NUM>');
         apps.fnd_file.put_line(apps.fnd_file.output
                               ,'    <DUE_DATE>'
                                || c_ap.due_date
                                || '</DUE_DATE>');
         apps.fnd_file.put_line(apps.fnd_file.output
                               ,'    <PAYMENT_METHOD_NAME>'
                                || c_ap.payment_method_name
                                || '</PAYMENT_METHOD_NAME>');
         apps.fnd_file.put_line(apps.fnd_file.output
                               ,'  </G_BATCH_NAME>');


         i :=   i
              + 1;
         k :=   k
              + 1;
      END LOOP;

      IF v_page_group IS NOT NULL
      THEN
         apps.fnd_file.put_line(apps.fnd_file.output
                               ,'</G_PAY_GROUP>');
      END IF;

      apps.fnd_file.put_line(apps.fnd_file.output
                            ,'</ROWSET>');
   EXCEPTION
      WHEN v_call_error
      THEN
         retcode := 2;
      WHEN v_error
      THEN
         retcode := 2;
         errbuf := errbuf
                   || CHR(10)
                   || '追縱報錯程式:'
                   || CHR(10)
                   || DBMS_UTILITY.format_error_stack
                   || DBMS_UTILITY.format_error_backtrace
                   || DBMS_UTILITY.format_call_stack;
      WHEN OTHERS
      THEN
         retcode := 2;
         errbuf := errbuf
                   || CHR(10)
                   || '追縱報錯程式:'
                   || CHR(10)
                   || DBMS_UTILITY.format_error_stack
                   || DBMS_UTILITY.format_error_backtrace
                   || DBMS_UTILITY.format_call_stack;
   END main;
-------------------------------------------------------------------------------------
END xxapry008_pkg;
/
CREATE OR REPLACE PACKAGE BODY APPS.xml_spreadsheet IS
/*----------------------------------------------------------------
||
||                 (c) public domain
-----------------------------------------------------------------*/
/*-----------------Module----------------------------------------
  Name             :    xml_spreadsheet.pcb
  Description      :    create Excel files in XML format
-----------------------------------------------------------------*/

/*-----------------History---------------------------------------------------------------
||
||  Date        Who                 Version What's new
||
||  25.10.2007  Matzberger Marcus   0.1     New
||  31.10.2007  Matzberger Marcus   0.2     Comments for Column title
||                                          Escape for german Umlaute and line break
||                                          write headers for new worksheet
||  06.11.2007  Matzberger Marcus   0.5     some minor bugs
||  05.01.2008  Matzberger Marcus   0.6     close and open worksheet as separate procedures
||  26.01.2008  Matzberger Marcus   0.7     allow more than one queries in query
||                                              allow custom cell formats and cell protection
||  09.02.2008  Matzberger Marcus   1.0     provide all features of this XML format
||                                              except named ranges
||  19.02.2008  Matzberger Marcus   1.1     write no <data> element when date is NULL
||  14.03.2008  Matzberger Marcus   1.1.1   don't escape characters in writequery as it is done in writeData
||                                              open new file with 32767. Metalink Note:358781.1
||  03.04.2008  Matzberger Marcus   1.1.2   fixed bug that prevented scrolling when first lines were fixed
||  09.05.2008  Matzberger Marcus   1.1.3   fixed typo in allowed values for vertical alignment
||  23.06.2008  Matzberger Marcus   1.1.4   ss:Index in uppercase
||                                              when a query returns more than p_maxRows in query then set columns on second/further sheet/s like on the first
||                                              wrap text is no longer default when no format is set,
||                                              but is set with any prefdefined text formats
||  25.07.2008  Matzberger Marcus   1.1.5   Write Formulas in date and text cells
||                                              newWorksheet and newDataRow with new parameter
||                                              getRelativeCellReference
||  13.09.2008  Matzberger Marcus   1.1.6   CHR(38) instead of ampersand to avoid SET DEFINE OFF on installation
||  20.09.2008  Matzberger Marcus   2.0     Write into CLOB
||  12.11.2008  Matzberger Marcus   2.1     Wordwrap as default for headers
||                                          createNewFile: new parameter for default font
||                                          closeWorksheet: print setup (margins and text)
||  30.03.2009  Matzberger Marcus   2.2     createNewFile: Character Encoding as parameter
||                                          repeat titles when printing as parameter in t_rec_caption
||  19.08.2010  Matzberger Marcus   2.3     Bugfix: Error when the full list of sumColumn was not supplying (Found and repaired by Ian Allen)
||                                          New predefined format: percent with 2 decimals
||  19.01.2011  Ian Allen           2.4     Better performance for big CLOB files
||  21.03.2014  Storck Ralf         2.5     New parameter for autofilter (row, colFrom, colTo)
||                                          Author name in comments
||  30.04.2014  Matzberger Marcus   2.5.1   Bugfix for author name
||  13.05.2014  Matzberger Marcus   2.5.2   Repeat Header on every page when printing
||                                          Define print area
||  19.01.2015  Nolem Lin           2.5.2   Fix put_data clob 32k bug 
                                            adjust charset to UTF-8 ,change abfrage to US name "Query"
||  20.01.2015  Nolem Lin           2.5.5   Add put_data overwrite procedure for fnd_file, Add Package parameter "g_apps" varchar2 Default 'Y' 
                                            for EBS concurent output or Database output . 
-----------------------------------------------------------------*/

    c_packageName           CONSTANT VARCHAR2(80) := 'xml_spreadsheet';
    g_debug                 BOOLEAN := FALSE;

    g_desc_t                dbms_sql.desc_tab;

    e_invalidPath           EXCEPTION;


--

PROCEDURE pld
    (
     p_text                 IN VARCHAR2
    )
IS
BEGIN
    IF g_debug THEN 
      IF g_apps ='N' THEN
        PUT_LINE_UNLIMIT(p_text);
       -- dbms_output.put_line('% '||SUBSTR(p_text,1,253));
      ELSE
        fnd_file.put_line(fnd_file.LOG,p_text);
      END IF;  
    END IF;

END pld;


--Get User Profile  FND_NATIVE_CLIENT_ENCODING value , and convert to xml encoding charset   
PROCEDURE convert_ebs_encode(o_xml_encode in out varchar2) 
IS
BEGIN
   if FND_PROFILE.value('FND_NATIVE_CLIENT_ENCODING') in ('ZHT16BIG5','ZHT16MSWIN950') then
    o_xml_encode :='big5';
   else
    o_xml_encode :='UTF-8'; 
   end if; 
END;



/*-----------------------------------------------------------------------------
||  Name:         checkPath
||  Description:  check whether p_path exists in all_directories
||  Parameter:    p_path - directory path
-----------------------------------------------------------------------------*/
PROCEDURE checkPath
    (
     p_path                 IN VARCHAR2
    )
IS
    v_count                 PLS_INTEGER;
BEGIN
    pld('checkPath p_path '||p_path);

    SELECT  COUNT(*)
    INTO    v_count
    FROM    all_directories
    WHERE   directory_name = p_path;

    IF v_count = 0 THEN
        RAISE e_invalidPath;
    END IF;

END checkPath;

/*-----------------------------------------------------------------------------
||  Name:         fopen
||  Description:  Open new file
||  Parameter:    p_path - valid directory_path
||                p_filename - file name
-----------------------------------------------------------------------------*/
FUNCTION fopen
    (
     p_path                 IN VARCHAR2
    ,p_filename             IN VARCHAR2
    )
    RETURN utl_file.FILE_TYPE
IS

    v_fileHandle            utl_file.FILE_TYPE;

    v_argsstr               VARCHAR2(200)   := SUBSTR(
                                                'p_path '||p_path||','||
                                                'p_filename '||p_filename
                                                ,1,500);

BEGIN
    pld('fopen p_filename '||p_filename);

    v_fileHandle := utl_file.fopen (p_path, p_filename, 'W');

    RETURN v_fileHandle;

EXCEPTION
    WHEN utl_file.INVALID_PATH THEN
        RAISE_APPLICATION_ERROR(
             -20001
            ,SUBSTR(
                 'Error in '||c_packageName||'.fopen: ' ||
                 v_argsstr ||' invalid_path',1,255)
                );
    WHEN utl_file.INVALID_MODE THEN
        RAISE_APPLICATION_ERROR(
             -20001
            ,SUBSTR(
                 'Error in '||c_packageName||'.fopen: ' ||
                 v_argsstr ||' invalid_mode',1,255)
                );
    WHEN utl_file.INVALID_FILEHANDLE THEN
        RAISE_APPLICATION_ERROR(
             -20001
            ,SUBSTR(
                 'Error in '||c_packageName||'.fopen: ' ||
                 v_argsstr ||' invalid_filehandle',1,255)
                );
    WHEN utl_file.INVALID_OPERATION THEN
        RAISE_APPLICATION_ERROR(
             -20001
            ,SUBSTR(
                 'Error in '||c_packageName||'.fopen: ' ||
                 v_argsstr ||' invalid_operation',1,255)
                );
    WHEN utl_file.READ_ERROR THEN
        RAISE_APPLICATION_ERROR(
             -20001
            ,SUBSTR(
                 'Error in '||c_packageName||'.fopen: ' ||
                 v_argsstr ||' read_error',1,255)
                );
    WHEN utl_file.WRITE_ERROR THEN
        RAISE_APPLICATION_ERROR(
             -20001
            ,SUBSTR(
                 'Error in '||c_packageName||'.fopen: ' ||
                 v_argsstr ||' write_error',1,255)
                );
    WHEN utl_file.INTERNAL_ERROR THEN
        RAISE_APPLICATION_ERROR(
             -20001
            ,SUBSTR(
                 'Error in '||c_packageName||'.fopen: ' ||
                 v_argsstr ||' internal_error',1,255)
                );
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(
             -20001
            ,SUBSTR(
                 'Error in '||c_packageName||'.fopen: ' ||
                 v_argsstr ||' ' ||
                 SQLERRM,1,255)
                );
END fopen;

/*-----------------------------------------------------------------------------
||  Name:         fclose
||  Description:  close a file
||  Parameter:    p_fileHandle - file handle from 'fopen'
-----------------------------------------------------------------------------*/
PROCEDURE fclose
    (
     p_fileHandle           IN utl_file.FILE_TYPE
    )
IS

    v_fileHandle            utl_file.FILE_TYPE := p_fileHandle;

BEGIN
    pld('fclose');

    IF utl_file.is_open (v_fileHandle) THEN
        utl_file.fclose (v_fileHandle);
    END IF;

END fclose;


/*-----------------------------------------------------------------------------
||  Name:         put_line
||  Description:  write a line into a clob
||  Parameter:    p_clob - clob to append line to
||                p_line - string to be written
-----------------------------------------------------------------------------*/
PROCEDURE put_line
    (
     p_clob                 IN OUT NOCOPY CLOB
    ,p_line                 IN VARCHAR2
    )
IS
BEGIN
    pld('put_line p_line '||p_line);
    dbms_lob.writeAppend(p_clob, LENGTH(p_line||CHR(10)), p_line||CHR(10));
END put_line;

/*-----------------------------------------------------------------------------
||  Name:         put_line
||  Description:  write a line into an open file
||  Parameter:    p_fileHandle - file handle from 'fopen'
||                p_line - string to be written
-----------------------------------------------------------------------------*/
PROCEDURE put_data
    (
     p_fileHandle           IN utl_file.FILE_TYPE
    ,p_clob                 IN CLOB
    )
IS
    l_amt NUMBER := 4000;
    l_offset NUMBER := 1;
    position INTEGER := 1;
    contador integer;
    l_length NUMBER :=0 ;  
    x varchar2(32000);
BEGIN
--  v1 := p_clob;
--  v2 := REPLACE_XML_CHAR(V1);
--  PUT_LINE_UNLIMIT(v2);
 --REPLACE_XML_CHAR(p_clob);
  
  position := 1;
  l_offset := 1;
  l_amt := 4000;
  l_length := DBMS_LOB.GETLENGTH(p_clob);
  pld('put_data utl_file  DBMS_LOB.GETLENGTH:'||l_length);
  WHILE (l_offset < l_length) LOOP
     IF (l_amt > (l_length - l_offset)) THEN 
       l_amt := l_length - l_offset + 1;
     END IF;     
     DBMS_LOB.READ(p_clob, l_amt, l_offset, x);
     UTL_FILE.put_raw(p_fileHandle, utl_raw.cast_to_raw(x), TRUE);    
     l_offset := l_offset + l_amt;
     position := position + 4000;
     x := null;
   END LOOP;  
   UTL_FILE.FFLUSH(p_fileHandle);
  --  dbms_xslprocessor.clob2file(p_clob,'XX_REPORT_FILE','3.csv');
 --PUT_LINE_UNLIMIT('Clob raw Length = '|| utl_raw.cast_to_raw(p_clob) );   
    
END put_data;

PROCEDURE put_data
    (
     p_AppsfileHandle       IN NUMBER
    ,p_clob                 IN CLOB
    )
IS
    l_amt NUMBER := 4000;
    l_offset NUMBER := 1;
    position INTEGER := 1;
    contador integer;
    l_length NUMBER :=0 ;  
    x varchar2(32000);
BEGIN
 --REPLACE_XML_CHAR(p_clob);
  position := 1;
  l_offset := 1;
  l_amt := 4000;
  l_length := DBMS_LOB.GETLENGTH(p_clob);
  pld('put_data fnd_file  DBMS_LOB.GETLENGTH:'||l_length);
  fnd_file.new_line(p_AppsfileHandle,1);
  WHILE (l_offset < l_length) LOOP
     IF (l_amt > (l_length - l_offset)) THEN 
       l_amt := l_length - l_offset + 1;
     END IF;     
     DBMS_LOB.READ(p_clob, l_amt, l_offset, x);
     fnd_file.put(p_AppsfileHandle,x);
     --UTL_FILE.put_raw(p_AppsfileHandle, utl_raw.cast_to_raw(x), TRUE);    
     l_offset := l_offset + l_amt;
     position := position + 4000;
     x := null;
   END LOOP;  

    
END put_data;


/*-----------------------------------------------------------------------------
||  Name:         getExcelColFromColNumber
||  Description:  gets the Excel column identifier from the current column number
||                e.g. 1 -> A, 10 -> J
||  Parameter:    p_number - current column number with 1 <= p_number <= 256
-----------------------------------------------------------------------------*/
FUNCTION getExcelColFromColNumber
    (
     p_number               IN PLS_INTEGER
    )
    RETURN VARCHAR2
IS
    v_ascii                 VARCHAR2(2);

    e_outOfRange            EXCEPTION;

    v_argsstr               VARCHAR2(500)   := SUBSTR(
                                                'p_number '||TO_CHAR(p_number)
                                                ,1,500);
BEGIN
    pld('getExcelColFromColNumber p_number '||p_number);

    IF p_number NOT BETWEEN 1 AND 256 THEN
        RAISE e_outOfRange;
    END IF;

    v_ascii := CHR(MOD(p_number,26) + 64);
    IF p_number > 26 THEN
        v_ascii := CHR(FLOOR(p_number / 26) + 64)||v_ascii;
    END IF;

    pld('.  v_ascii '||v_ascii);
    RETURN v_ascii;

EXCEPTION
    WHEN e_outOfRange THEN
        RAISE_APPLICATION_ERROR(
             -20001
            ,'Error in '||c_packageName||'.getExcelColFromColNumber: ' ||
             v_argsstr ||' ' ||
             'Value out of range 1 - 256'
             );
END getExcelColFromColNumber;

/*-----------------------------------------------------------------------------
||  Name:         convertNumberIntoExcelFormat
||  Description:  convert a numeric value into character with '.' as
||                decimal separator and max. 12 decimal places
||  Parameter:    p_number - number to be converted
-----------------------------------------------------------------------------*/
FUNCTION convertNumberIntoExcelFormat
    (
     p_number                 IN NUMBER
    )
    RETURN VARCHAR2
IS
    v_argsstr               VARCHAR2(500)   := SUBSTR(
                                                'p_number '||TO_CHAR(p_number)
                                                ,1,500);
BEGIN
    pld('convertNumberIntoExcelFormat p_number '||p_number);

    IF p_number IS NULL THEN
        RETURN NULL;
    ELSE
        RETURN TO_CHAR(p_number,'FM99999999999999999D999999999999','NLS_NUMERIC_CHARACTERS = ''.,''');
    END IF;

END convertNumberIntoExcelFormat;

/*-----------------------------------------------------------------------------
||  Name:         convertDateIntoExcelFormat
||  Description:  convert a date value into character
||  Parameter:    p_date - date to be converted
-----------------------------------------------------------------------------*/
FUNCTION convertDateIntoExcelFormat
    (
     p_date                 IN DATE
    )
    RETURN VARCHAR2
IS
    v_argsstr               VARCHAR2(500)   := SUBSTR(
                                                'p_date '||TO_CHAR(p_date)
                                                ,1,500);
BEGIN
    pld('convertDateIntoExcelFormat p_date '||p_date);

    RETURN TO_CHAR(p_date,'yyyy-mm-dd')||'T'||TO_CHAR(p_date,'hh24:mi:ss')||'Z';

END convertDateIntoExcelFormat;

/*-----------------------------------------------------------------------------
||  Name:         escapeSpecialCharacters
||  Description:  Masking of 'dangerous' letters, because of output as XML
||  Parameter:    p_text - string to be searched
-----------------------------------------------------------------------------*/
FUNCTION escapeSpecialCharacters
    (
     p_text                 IN VARCHAR2
    )
    RETURN VARCHAR2
IS
  l_processed_str     varchar2(4000);

BEGIN
  l_processed_str := p_text;
  pld('escapeSpecialCharacters');

  --Tab 符號
   if instr(l_processed_str, chr(9)) <> 0 then
      l_processed_str := replace(l_processed_str,chr(9), '');
   end if;
   /*
  --全形空白
   if instr(l_processed_str, '　') <> 0 then
      l_processed_str := replace(l_processed_str,'　', '');
   end if; --因GV小幫手需要顯示全形空白 XXAPRY018_PKG
   */ 
  --換行符號
   if instr(l_processed_str, chr(10)) <> 0 then
      l_processed_str := replace(l_processed_str,chr(10), '');
   end if;
  -- 特殊符號 &
   if instr(l_processed_str,'&') <> 0 then
      l_processed_str := replace(l_processed_str,'&','&#38;');
   end if;

   -- 特殊符號 <
   if instr(l_processed_str,'<') <> 0 then
      l_processed_str := replace(l_processed_str,'<','&#60;');
   end if;
   -- 特殊符號 >
   if instr(l_processed_str,'>') <> 0 then
     l_processed_str := replace(l_processed_str,'<','&#62;');
   end if;


    RETURN l_processed_str; 

END escapeSpecialCharacters;

/*-----------------------------------------------------------------------------
||  Name:         setStyleColor
||  Description:  formatting the string for text color
||  Parameter:    p_color - color
-----------------------------------------------------------------------------*/
FUNCTION setStyleColor
    (
     p_color                IN VARCHAR2
    )
    RETURN VARCHAR2
IS
BEGIN
    IF p_color IS NULL THEN
        RETURN NULL;
    ELSE
        RETURN 'color:'||p_color||';';
    END IF;

END setStyleColor;

/*-----------------------------------------------------------------------------
||  Name:         setBgColor
||  Description:  formatting the string for background color
||  Parameter:    p_color - color
-----------------------------------------------------------------------------*/
FUNCTION setBgColor
    (
     p_color                IN VARCHAR2
    )
    RETURN VARCHAR2
IS
BEGIN
    IF p_color IS NULL THEN
        RETURN NULL;
    ELSE
        RETURN 'background:'||p_color||';';
    END IF;

END setBgColor;

/*-----------------------------------------------------------------------------
||  Name:         setColspan
||  Description:  formatting the string for merging cells
||  Parameter:    p_colspan - Number of cells to be merged
-----------------------------------------------------------------------------*/
FUNCTION setColspan
    (
     p_colspan              IN PLS_INTEGER
    )
    RETURN VARCHAR2
IS
BEGIN
    IF p_colspan IS NULL THEN
        RETURN NULL;
    ELSE
        RETURN ' ss:MergeAcross="'||p_colspan||'" ' ;
    END IF;

END setColspan;

/*-----------------------------------------------------------------------------
||  Name:         writeConditionalFormatting
||  Description:  write information for formatting on given conditions
||  Parameter:    p_clob - clob to write content from 'createNewFile'
||                p_tab_conditionalFormats - collection with formatting information
-----------------------------------------------------------------------------*/
PROCEDURE writeConditionalFormatting
    (
     p_clob                   IN OUT NOCOPY CLOB
    ,p_tab_conditionalFormats IN t_tab_conditionalFormats
   )
IS
    v_range                 VARCHAR2(50);
BEGIN
    pld('writeConditionalFormatting');

    IF p_tab_conditionalFormats.COUNT > 0 THEN
        NULL;

        put_line(p_clob,'    <ConditionalFormatting xmlns="urn:schemas-microsoft-com:office:excel">');

        FOR j IN 1..p_tab_conditionalFormats.COUNT LOOP
            IF p_tab_conditionalFormats(j).range <> NVL(v_range,'X') THEN
                v_range := p_tab_conditionalFormats(j).range;
                put_line(p_clob,'   <Range>'||v_range||'</Range>');
            END IF;
            put_line(p_clob,'   <Condition>');
            put_line(p_clob,'    <Qualifier>'||p_tab_conditionalFormats(j).qualifier||'</Qualifier>');
            put_line(p_clob,'    <Value1>'||p_tab_conditionalFormats(j).value1||'</Value1>');

            IF p_tab_conditionalFormats(j).qualifier IN ('Between', 'NotBetween') THEN
                put_line(p_clob,'    <Value2>'||p_tab_conditionalFormats(j).value2||'</Value2>');
            END IF;

            put_line(p_clob
                    ,'    <Format Style='''||
                     setStyleColor(p_tab_conditionalFormats(j).formatColor)||
                     p_tab_conditionalFormats(j).formatEmphasis||
                     p_tab_conditionalFormats(j).formatMarkup||
                     setBgColor(p_tab_conditionalFormats(j).formatBgColor)||
                     '''/>');
            put_line(p_clob,'   </Condition>');

        END LOOP;

        put_line(p_clob,'    </ConditionalFormatting>');

    END IF;

END writeConditionalFormatting;

/*-----------------------------------------------------------------------------
||  Name:         writeAutofilter
||  Description:  write information for autofiltering columns
||  Parameter:    p_clob - clob to write content from 'createNewFile'
||                p_tab_caption - collection with caption information
||                p_autofilter - Set autofilter TRUE = Yes
||                p_rec_autofilter - custom autofilter Parameters
-----------------------------------------------------------------------------*/
PROCEDURE writeAutofilter
    (
     p_clob                 IN OUT NOCOPY CLOB
    ,p_tab_caption          IN t_tab_caption
    ,p_rec_autofilter       IN t_rec_autofilter
    ,p_autofilter           IN BOOLEAN
    )
IS
    v_autoFilterLine        PLS_INTEGER := 1;
    v_lastColumn            PLS_INTEGER := 1;

BEGIN
    pld('writeAutofilter');
    pld('. p_tab_caption.COUNT '||p_tab_caption.COUNT);
    pld('. p_rec_autofilter.row '||p_rec_autofilter.row);

    IF p_autofilter THEN
        IF p_tab_caption.COUNT > 0 THEN
            <<loop_testCaption>>
            FOR j IN 1..p_tab_caption.COUNT LOOP
                -- test whether super title (twoline caption) required
                IF p_tab_caption(j).topTitle IS NOT NULL THEN
                    v_autoFilterLine := 2;
                    EXIT loop_testCaption;
                END IF;
            END LOOP loop_testCaption;

            v_lastColumn    := p_tab_caption.COUNT;

            IF v_lastColumn = 0 THEN
                v_lastColumn := 1;
            END IF;
            put_line(p_clob,'  <AutoFilter '||
                                'x:Range="R'||TO_CHAR(v_autoFilterLine)||
                                'C1:'||
                                'R'||TO_CHAR(v_autoFilterLine)||
                                'C'||TO_CHAR(v_lastColumn)||'" '||
                                'xmlns="urn:schemas-microsoft-com:office:excel">');
            put_line(p_clob,'  </AutoFilter>');
        ELSIF p_rec_autofilter.row IS NOT NULL THEN
            put_line(p_clob,'  <AutoFilter '||
                                'x:Range="R'  || TO_CHAR(p_rec_autofilter.row)||
                                'C'  || TO_CHAR(p_rec_autofilter.colfrom)||
                                ':R' || TO_CHAR(p_rec_autofilter.row)||
                                'C'  || TO_CHAR(p_rec_autofilter.colTo)||'" '||
                                'xmlns="urn:schemas-microsoft-com:office:excel">');
            put_line(p_clob,'  </AutoFilter>');
        END IF;
    END IF;

END writeAutofilter;

/*-----------------------------------------------------------------------------
||  Name:         setURL
||  Description:  formatting the string for URL
||  Parameter:    p_url - url
-----------------------------------------------------------------------------*/
FUNCTION setURL
    (
     p_url                  IN VARCHAR2
    )
    RETURN VARCHAR2
IS

BEGIN

    IF p_url IS NULL THEN
        RETURN NULL;
    ELSE
        RETURN ' ss:HRef="'||p_url||'" ';
    END IF;

END setURL;

/*-----------------------------------------------------------------------------
||  Name:         setIndex
||  Description:  formatting the string for cell index
||  Parameter:    p_index - index
-----------------------------------------------------------------------------*/
FUNCTION setIndex
    (
     p_index                IN VARCHAR2
    )
    RETURN VARCHAR2
IS

BEGIN
    pld('setIndex');
    pld('. p_index '||p_index);

    IF p_index IS NULL THEN
        RETURN NULL;
    ELSE
        RETURN ' ss:Index="'||p_index||'" ';
    END IF;

END setIndex;

/*-----------------------------------------------------------------------------
||  Name:         setProtected
||  Description:  formatting the string for cell protection
||  Parameter:    p_value - protect cell True/False
-----------------------------------------------------------------------------*/
FUNCTION setProtected
    (
     p_value                IN BOOLEAN
    )
    RETURN VARCHAR2
IS

BEGIN

    IF p_value THEN
        RETURN ' ss:Protected="1" ';
    ELSIF NOT p_value THEN
        RETURN ' ss:Protected="0" ';
    ELSE
        RETURN NULL;
    END IF;

END setProtected;

/*-----------------------------------------------------------------------------
||  Name:         setHidden
||  Description:  formatting the string for hiding columns
||  Parameter:    p_value - hide column True/False
-----------------------------------------------------------------------------*/
FUNCTION setHidden
    (
     p_value                IN BOOLEAN
    )
    RETURN VARCHAR2
IS

BEGIN

    IF p_value THEN
        RETURN ' ss:Hidden="1" ';
    ELSIF NOT p_value THEN
        RETURN ' ss:Hidden="0" ';
    ELSE
        RETURN NULL;
    END IF;

END setHidden;

/*-----------------------------------------------------------------------------
||  Name:         setAutoFitWidth
||  Description:  formatting the string for automatic column width
||  Parameter:    p_value - set column width automatically True/False
-----------------------------------------------------------------------------*/
FUNCTION setAutoFitWidth
    (
     p_value                IN BOOLEAN
    )
    RETURN VARCHAR2
IS

BEGIN

    IF p_value THEN
        RETURN ' ss:AutoFitWidth="1" ';
    ELSIF NOT p_value THEN
        RETURN ' ss:AutoFitWidth="0" ';
    ELSE
        RETURN NULL;
    END IF;

END setAutoFitWidth;

/*-----------------------------------------------------------------------------
||  Name:         setHeight
||  Description:  formatting the string for row height
||  Parameter:    p_value - height
-----------------------------------------------------------------------------*/
FUNCTION setHeight
    (
     p_value                IN PLS_INTEGER
    )
    RETURN VARCHAR2
IS

BEGIN

    IF p_value IS NOT NULL THEN

        IF p_value NOT BETWEEN 0 AND 255 THEN
            RAISE_APPLICATION_ERROR(-20001,'Value '||p_value||' not allowed for row height');
        END IF;

        RETURN ' ss:Height="'||TO_CHAR(p_value)||'" ';
    ELSE
        RETURN NULL;
    END IF;

END setHeight;

/*-----------------------------------------------------------------------------
||  Name:         setWidth
||  Description:  formatting the string for column width
||  Parameter:    p_value - width
-----------------------------------------------------------------------------*/
FUNCTION setWidth
    (
     p_value                IN PLS_INTEGER
    )
    RETURN VARCHAR2
IS

BEGIN

    IF p_value IS NOT NULL THEN

        IF p_value NOT BETWEEN 0 AND 600 THEN
            RAISE_APPLICATION_ERROR(-20001,'Value '||p_value||' not allowed for column width');
        END IF;

        RETURN ' ss:Width="'||TO_CHAR(p_value)||'" ';
    ELSE
        RETURN NULL;
    END IF;

END setWidth;

/*-----------------------------------------------------------------------------
||  Name:         setFormat
||  Description:  formatting the string for Style ID
||  Parameter:    p_value - valid Style ID
-----------------------------------------------------------------------------*/
FUNCTION setFormat
    (
     p_value                IN VARCHAR2
    )
    RETURN VARCHAR2
IS

BEGIN

    IF p_value IS NOT NULL THEN
        RETURN ' ss:StyleID="'||p_value ||'" ';
    ELSE
        RETURN NULL;
    END IF;

END setFormat;

/*-----------------------------------------------------------------------------
||  Name:         setRepeatTitle
||  Description:  formatting the string for printing titles on each page
||  Parameter:    p_value - TRUE = Yes
-----------------------------------------------------------------------------*/
FUNCTION setRepeatTitle
    (
     p_value                IN BOOLEAN
    )
    RETURN VARCHAR2
IS

BEGIN

    IF p_value THEN
        RETURN ' <NamedCell ss:Name="Print_Titles"/> ';
    ELSE
        RETURN NULL;
    END IF;

END setRepeatTitle;

/*-----------------------------------------------------------------------------
||  Name:         formatFormula
||  Description:  formatting the string for formula
||  Parameter:    p_formula - formula
-----------------------------------------------------------------------------*/
FUNCTION formatFormula
    (
     p_formula              IN VARCHAR2
    )
    RETURN VARCHAR2
IS

BEGIN

    IF p_formula IS NULL THEN
        RETURN NULL;
    ELSE
        RETURN ' ss:Formula="'||escapeSpecialCharacters(p_formula)||'" ';
    END IF;

END formatFormula;

/*-----------------------------------------------------------------------------
||  Name:         formatComment
||  Description:  formatting the string for cell comments
||  Parameter:    p_comment - comment
-----------------------------------------------------------------------------*/
FUNCTION formatComment
    (
     p_comment              IN VARCHAR2
    )
    RETURN VARCHAR2
IS
    v_author                VARCHAR2(100);
    v_comment               VARCHAR2(1000) := p_comment;
    v_posBy                 PLS_INTEGER;

BEGIN
    --author is appended to comment after ##by##
    v_posBy     := INSTR(p_comment,'##by##');
    IF v_posBy > 0 THEN
        v_author    := SUBSTR(p_comment,v_posBy + 6);
    END IF;

    IF v_author IS NOT NULL THEN
        v_comment := REPLACE(v_comment,'##by##'||v_author,'');
    ELSE
        v_author  := SYS_CONTEXT ('USERENV', 'OS_USER');
    END IF;

    IF p_comment IS NULL THEN
        RETURN NULL;
    ELSE
        RETURN '<Comment ss:Author="'||SYS_CONTEXT ('USERENV', 'OS_USER')||'">'||
               '<ss:Data xmlns="http://www.w3.org/TR/REC-html40">'||
               '<B><Font html:Face="Tahoma" html:Size="8" html:Color="#000000">'||v_author||':</Font></B>'||
               '<Font html:Face="Tahoma" html:Size="8" html:Color="#000000"> '||escapeSpecialCharacters(v_comment)||'</Font>'||
               '</ss:Data>'||
               '</Comment>';
    END IF;

END formatComment;

/*-----------------------------------------------------------------------------
||  Name:         writeColumns
||  Description:  Write column settings
||  Parameter:    p_clob - clob to write content from 'createNewFile'
||                p_tab_columns - collection with column settings
-----------------------------------------------------------------------------*/
PROCEDURE writeColumns
    (
     p_clob                 IN OUT NOCOPY CLOB
    ,p_tab_columns          IN t_tab_columns
    )
IS

BEGIN
    pld('writeColumns');
    pld('.  p_tab_columns.COUNT '||p_tab_columns.COUNT);

    FOR j IN 1..p_tab_columns.COUNT LOOP

        put_line(
             p_clob
            ,'   <Column '||
             setFormat(p_tab_columns(j).cFormat)||
             setAutoFitWidth(p_tab_columns(j).cAutowidth)||
             setHidden(p_tab_columns(j).cHidden)||
             setWidth(p_tab_columns(j).cWidth)||
             setIndex(p_tab_columns(j).cIndex)||
             ' />');

    END LOOP;

END writeColumns;

/*-----------------------------------------------------------------------------
||  Name:         writeCaption
||  Description:  Write caption and open first data row
||  Parameter:    p_clob - clob to write content from 'createNewFile'
||                p_tab_caption - collection with caption information
-----------------------------------------------------------------------------*/
PROCEDURE writeCaption
    (
     p_clob                 IN OUT NOCOPY CLOB
    ,p_tab_caption          IN t_tab_caption
    )
IS
    v_topTitleExists        BOOLEAN := FALSE;
    v_colspan               VARCHAR2(20) := '';
    v_style                 VARCHAR2(3) := 'sh1';
    v_repeatTitle           BOOLEAN;
BEGIN
    pld('writeCaption');
    pld('. p_tab_caption.COUNT '||p_tab_caption.COUNT);

    FOR j IN 1..p_tab_caption.COUNT LOOP

        -- test whether super title (twoline caption) required
        IF p_tab_caption(j).topTitle IS NOT NULL THEN
            v_topTitleExists := TRUE;
            EXIT;
        END IF;

    END LOOP;

    put_line(p_clob,'   <Row>');

    IF v_topTitleExists THEN
        -- when super title exist, then write them
        FOR j IN 1..p_tab_caption.COUNT LOOP
            IF p_tab_caption(j).topTitle IS NOT NULL THEN
                v_colspan   := TO_CHAR(NVL(p_tab_caption(j).span,1) - 1);
               put_line(
                     p_clob
                    ,'    <Cell ss:MergeAcross="'||v_colspan||'" ss:StyleID="'||v_style||'">'||
                     '<Data ss:Type="String">'||p_tab_caption(j).topTitle||'</Data>'||
                     '</Cell>');
                IF j = 1 THEN
                    v_style := 'sh2';
                END IF;
            END IF;
        END LOOP;
        put_line(p_clob,'   </Row>');
        put_line(p_clob,'   <Row>');

    END IF;

    v_style := 'sh1';

    FOR j IN 1..p_tab_caption.COUNT LOOP

        IF j = 1 THEN
            v_repeatTitle := p_tab_caption(j).repeatTitle;
        END IF;

        put_line(p_clob
                ,'    <Cell ss:StyleID="'||v_style||'">'||
                 '<Data ss:Type="String">'||escapeSpecialCharacters(p_tab_caption(j).title)||'</Data>'||
                 formatComment(p_tab_caption(j).comment)||setRepeatTitle(v_repeatTitle)||
                 '</Cell>');
        IF j = 1 THEN
            v_style := 'sh2';
        END IF;

    END LOOP;

    put_line(p_clob,'   </Row>');

END writeCaption;

/*-----------------------------------------------------------------------------
||  Name:         writeNamedRange
||  Description:  Write Named Range for repeating titles
||  Parameter:    p_clob - clob to write content from 'createNewFile'
||                p_tab_caption - collection with caption information
-----------------------------------------------------------------------------*/
PROCEDURE writeNamedRange
    (
     p_clob                 IN OUT NOCOPY CLOB
    ,p_tab_caption          IN t_tab_caption
    ,p_rec_printSetup       IN t_rec_printSetup
    ,p_sheetname            IN VARCHAR2
    )
IS
    v_row                   PLS_INTEGER := 1;
BEGIN
    IF p_tab_caption.EXISTS(1) THEN
        IF p_tab_caption(1).repeatTitle THEN
            FOR j IN 1..p_tab_caption.COUNT LOOP
                -- test whether super title (twoline caption) required
                IF p_tab_caption(j).topTitle IS NOT NULL THEN
                    v_row := 2;
                    EXIT;
                END IF;
            END LOOP;
            put_line(p_clob,'  <Names>');
            put_line(p_clob,'   <NamedRange ss:Name="Print_Titles" ss:RefersTo="='''||p_sheetname||'''!R'||TO_CHAR(v_row)||'"/>');
            put_line(p_clob,'  </Names>');
        END IF;

    ELSE
        put_line(p_clob,'  <Names>');
        IF p_rec_printSetup.printTitle IS NOT NULL THEN
            put_line(p_clob,'   <NamedRange ss:Name="Print_Titles" ss:RefersTo="='''||p_sheetname||'''!'||REPLACE(p_rec_printSetup.printTitle,',',','''||p_sheetname||'''!')||'"/>');
        END IF;--ss:RefersTo="=Tabelle1!C1:C3,Tabelle1!R1:R4"/>
        IF p_rec_printSetup.printArea IS NOT NULL THEN
            put_line(p_clob,'   <NamedRange ss:Name="Print_Area" ss:RefersTo="='''||p_sheetname||'''!'||p_rec_printSetup.printArea||'"/>');
        END IF;--ss:RefersTo="=Tabelle1!R1C1:R33C13"
        put_line(p_clob,'  </Names>');
    END IF;

END writeNamedRange;

FUNCTION setParent
    (
     p_type                 IN VARCHAR2
    )
    RETURN VARCHAR2
IS
BEGIN
    IF UPPER(p_type) = 'PERCENT' THEN
        RETURN ' ss:Parent="''||c_prozent||''';
    ELSE
        RETURN NULL;
    END IF;
END setParent;

FUNCTION setHAlign
    (
     p_value                IN VARCHAR2
    )
    RETURN VARCHAR2
IS
BEGIN

    IF p_value IS NOT NULL THEN

        IF INITCAP(p_value) NOT IN ('Left', 'Center', 'Right', 'Justify', 'Fill') THEN
            RAISE_APPLICATION_ERROR(-20001,'Value '||p_value||' not allowed for hAlign');
        END IF;

        RETURN ' ss:Horizontal="'||INITCAP(p_value)||'" ';
    ELSE
        RETURN NULL;
    END IF;
END setHAlign;

FUNCTION setVAlign
    (
     p_value                IN VARCHAR2
    )
    RETURN VARCHAR2
IS
BEGIN

    IF p_value IS NOT NULL THEN

        IF INITCAP(p_value) NOT IN ('Top', 'Bottom', 'Center') THEN
            RAISE_APPLICATION_ERROR(-20001,'Value '||p_value||' not allowed for vAlign');
        END IF;

        RETURN ' ss:Vertical="'||INITCAP(p_value)||'" ';
    ELSE
        RETURN NULL;
    END IF;
END setVAlign;

FUNCTION setTextRotate
    (
     p_value                IN PLS_INTEGER
    )
    RETURN VARCHAR2
IS
BEGIN

    IF p_value IS NOT NULL THEN

        IF p_value NOT BETWEEN -90 AND 90 THEN
            RAISE_APPLICATION_ERROR(-20001,'Value '||p_value||' not allowed for textRotate');
        END IF;

        RETURN ' ss:Rotate="'||TO_CHAR(p_value)||'" ';
    ELSE
        RETURN NULL;
    END IF;

END setTextRotate;

FUNCTION setReadingOrder
    (
     p_value                IN VARCHAR2
    )
    RETURN VARCHAR2
IS
BEGIN

    IF p_value IS NOT NULL THEN

        IF p_value NOT IN ('RightToLeft','LeftToRight','Context') THEN
            RAISE_APPLICATION_ERROR(-20001,'Value '||p_value||' not allowed for Reading Order');
        END IF;

        RETURN ' ss:ReadingOrder="'||p_value||'" ';
    ELSE
        RETURN NULL;
    END IF;
END setReadingOrder;

FUNCTION setShrinkToFit
    (
     p_value                IN BOOLEAN
    )
    RETURN VARCHAR2
IS

BEGIN

    IF p_value THEN
        RETURN ' ss:ShrinkToFit="1" ';
    ELSE
        RETURN NULL;
    END IF;

END setShrinkToFit;

FUNCTION setVerticalText
    (
     p_value                IN BOOLEAN
    )
    RETURN VARCHAR2
IS

BEGIN

    IF p_value THEN
        RETURN ' ss:VerticalText="1" ';
    ELSIF NOT p_value THEN
        RETURN ' ss:VerticalText="0" ';
    ELSE
        RETURN NULL;
    END IF;

END setVerticalText;

FUNCTION setWrapText
    (
     p_value                IN BOOLEAN
    )
    RETURN VARCHAR2
IS

BEGIN

    IF p_value THEN
        RETURN ' ss:WrapText="1" ';
    ELSIF NOT p_value THEN
        RETURN ' ss:WrapText="0" ';
    ELSE
        RETURN NULL;
    END IF;

END setWrapText;

PROCEDURE writeAlign
    (
     p_clob           IN OUT NOCOPY CLOB
    ,p_rec_alignement       IN t_rec_alignment
    )
IS

BEGIN
    IF   p_rec_alignement.vertical IS NOT NULL
      OR p_rec_alignement.horizontal IS NOT NULL
      OR p_rec_alignement.textRotate IS NOT NULL
      OR p_rec_alignement.readingOrder IS NOT NULL
      OR p_rec_alignement.shrinkToFit IS NOT NULL
      OR p_rec_alignement.verticalText IS NOT NULL
      OR p_rec_alignement.wrapText IS NOT NULL
    THEN
        put_line(
             p_clob
            ,'   <Alignment '||
            setHAlign(p_rec_alignement.horizontal)||
            setVAlign(p_rec_alignement.vertical)||
            setTextRotate(p_rec_alignement.textRotate)||
            setReadingOrder(p_rec_alignement.readingOrder)||
            setShrinkToFit(p_rec_alignement.shrinkToFit)||
            setVerticalText(p_rec_alignement.verticalText)||
            setWrapText(p_rec_alignement.wrapText)||
            ' />'
            );
    END IF;

END writeAlign;

FUNCTION setLineStyle
    (
     p_value                IN VARCHAR2
    )
    RETURN VARCHAR2
IS
BEGIN

    IF p_value IS NOT NULL THEN

        IF p_value NOT IN ('Continuous','Dot', 'DashDot', 'DashDotDot', 'Dash', 'SlantDashDot', 'Double') THEN
            RAISE_APPLICATION_ERROR(-20001,'Value '||p_value||' not allowed for line style');
        END IF;

        RETURN ' ss:LineStyle="'||p_value||'" ';
    ELSE
        RETURN ' ss:LineStyle="Continuous" ';
    END IF;

END setLineStyle;

FUNCTION setWeight
    (
     p_value                IN PLS_INTEGER
    )
    RETURN VARCHAR2
IS
BEGIN

    IF p_value IS NOT NULL THEN

        IF p_value NOT BETWEEN 0 AND 3 THEN
            RAISE_APPLICATION_ERROR(-20001,'Value '||p_value||' not allowed for border weight');
        END IF;

        RETURN ' ss:Weight="'||TO_CHAR(p_value)||'" ';
    ELSE
        RETURN ' ss:Weight="0" ';
    END IF;

END setWeight;

FUNCTION setColor
    (
     p_value                IN VARCHAR2
    )
    RETURN VARCHAR2
IS
BEGIN

    IF p_value IS NOT NULL THEN
        RETURN ' ss:Color="'||p_value||'" ';
    ELSE
        RETURN NULL;
    END IF;

END setColor;

PROCEDURE writeBorder
    (
     p_clob                 IN OUT NOCOPY CLOB
    ,p_position             IN VARCHAR2
    ,p_rec_border           IN t_rec_border
    )
IS
BEGIN
        put_line(
             p_clob
            ,'    <Border '||
            ' ss:Position="'||p_position||'" '||
            setLineStyle(p_rec_border.bLineStyle)||
            setWeight(p_rec_border.bWeight)||
            setColor(NVL(p_rec_border.bColor,'#000000'))||
            '/>'
            );

END writeBorder;

PROCEDURE writeBorders
    (
     p_clob                 IN OUT NOCOPY CLOB
    ,p_tab_border           IN t_tab_border
    )
IS
    v_position              VARCHAR2(100);
    v_countTop              PLS_INTEGER := 0;
    v_countBottom           PLS_INTEGER := 0;
    v_countLeft             PLS_INTEGER := 0;
    v_countRight            PLS_INTEGER := 0;
    v_countDiagonalRight    PLS_INTEGER := 0;
    v_countDiagonalLeft     PLS_INTEGER := 0;
BEGIN
    pld('writeBorders');
    pld('. p_tab_border.COUNT '||p_tab_border.COUNT);

    IF p_tab_border.COUNT > 0 THEN
        put_line(p_clob,'   <Borders>');

        FOR j IN p_tab_border.FIRST .. p_tab_border.LAST LOOP

            v_position  := REPLACE(','||UPPER(p_tab_border(j).bPosition)||',',' ','');

            IF v_position LIKE '%,BOTTOM,%' THEN
                writeBorder(p_clob,'Bottom',p_tab_border(j));
                v_countBottom   := v_countBottom + 1;
            END IF;

           IF v_position LIKE '%,LEFT,%' THEN
                writeBorder(p_clob,'Left',p_tab_border(j));
                v_countLeft := v_countLeft + 1;
            END IF;

            IF v_position LIKE '%,RIGHT,%' THEN
                writeBorder(p_clob,'Right',p_tab_border(j));
                v_countRight    := v_countRight + 1;
            END IF;

            IF v_position LIKE '%,TOP,%' THEN
                writeBorder(p_clob,'Top',p_tab_border(j));
                v_countTop  := v_countTop + 1;
            END IF;

            IF v_position LIKE '%,DIAGONALRIGHT,%' THEN
                writeBorder(p_clob,'DiagonalRight',p_tab_border(j));
                v_countDiagonalRight    := v_countDiagonalRight + 1;
            END IF;

            IF v_position LIKE '%,DIAGONALLEFT,%' THEN
                writeBorder(p_clob,'DiagonalLeft',p_tab_border(j));
                v_countDiagonalLeft := v_countDiagonalLeft + 1;
            END IF;

        END LOOP;

        IF   v_countTop           > 1
          OR v_countBottom        > 1
          OR v_countLeft          > 1
          OR v_countRight         > 1
          OR v_countDiagonalRight > 1
          OR v_countDiagonalLeft  > 1
        THEN
            RAISE_APPLICATION_ERROR(-20001,'Multiple definitions of border position');
        END IF;

        put_line(p_clob,'   </Borders>');

    END IF;

END writeBorders;

FUNCTION setName
    (
     p_value                IN VARCHAR2
    )
    RETURN VARCHAR2
IS
BEGIN

    IF p_value IS NOT NULL THEN
        RETURN ' ss:FontName="'||p_value||'" ';
    ELSE
        RETURN NULL;
    END IF;

END setName;

FUNCTION setFamily
    (
     p_value                IN VARCHAR2
    )
    RETURN VARCHAR2
IS
BEGIN
    IF p_value NOT IN ('Automatic', 'Decorative', 'Modern', 'Roman', 'Script', 'Swiss') THEN
        RAISE_APPLICATION_ERROR(-20001,'Value '||p_value||' not allowed for font family');
    END IF;

    IF p_value IS NOT NULL THEN
        RETURN ' x:Family="'||p_value||'" ';
    ELSE
        RETURN NULL;
    END IF;

END setFamily;

FUNCTION setSize
    (
     p_value                IN PLS_INTEGER
    )
    RETURN VARCHAR2
IS
BEGIN

    IF p_value IS NOT NULL THEN

        IF p_value < 5 THEN
            RAISE_APPLICATION_ERROR(-20001,'Value '||p_value||' not allowed for text size');
        END IF;

        RETURN ' ss:Size="'||TO_CHAR(p_value)||'" ';
    ELSE
        RETURN NULL;
    END IF;

END setSize;

FUNCTION setEmphasis
    (
     p_bold                 IN BOOLEAN
    ,p_italic               IN BOOLEAN
    ,p_strike               IN BOOLEAN
    )
    RETURN VARCHAR2
IS
    v_emphasis              VARCHAR2(200);
BEGIN


    IF p_bold THEN
        v_emphasis  := ' ss:Bold="1" ';
    ELSIF NOT p_bold THEN
        v_emphasis  := ' ss:Bold="0" ';
    END IF;

    IF p_italic THEN
        v_emphasis  := v_emphasis||' ss:Italic="1" ';
    ELSIF NOT p_italic THEN
        v_emphasis  := ' ss:Italic="0" ';
    END IF;

    IF p_strike THEN
        v_emphasis  := v_emphasis||' ss:StrikeThrough="1" ';
    ELSIF NOT p_strike THEN
        v_emphasis  := ' ss:StrikeThrough="0" ';
    END IF;

    RETURN v_emphasis;

END setEmphasis;

FUNCTION setVerticalAlign
    (
     p_value                IN VARCHAR2
    )
    RETURN VARCHAR2
IS
BEGIN

    IF p_value IS NOT NULL THEN

        IF p_value NOT IN ('Superscript','Subscript') THEN
            RAISE_APPLICATION_ERROR(-20001,'Value '||p_value||' not allowed for text size');
        END IF;

        RETURN ' ss:VerticalAlign="'||p_value||'" ';
    ELSE
        RETURN NULL;
    END IF;

END setVerticalAlign;

FUNCTION setUnderline
    (
     p_value                IN VARCHAR2
    )
    RETURN VARCHAR2
IS
    v_value                 VARCHAR2(30);
BEGIN

    IF p_value IS NOT NULL THEN

        IF LOWER(p_value) = 's' THEN
            v_value := 'Single';
        ELSIF LOWER(p_value) = 'd' THEN
            v_value := 'Double';
        ELSIF LOWER(p_value) = 'as' THEN
            v_value := 'SingleAccounting';
        ELSIF LOWER(p_value) = 'ad' THEN
            v_value := 'DoubleAccounting';
        ELSE
            RAISE_APPLICATION_ERROR(-20001,'Value '||p_value||' not allowed for text underline');
        END IF;

        RETURN ' ss:Underline="'||v_value||'" ';
    ELSE
        RETURN NULL;
    END IF;

END setUnderline;

PROCEDURE writeFont
    (
     p_clob                 IN OUT NOCOPY CLOB
    ,p_rec_font             IN t_rec_font
    )
IS

BEGIN

    IF   p_rec_font.fName IS NOT NULL
      OR p_rec_font.fFamily IS NOT NULL
      OR p_rec_font.fSize IS NOT NULL
      OR p_rec_font.fColor IS NOT NULL
      OR p_rec_font.fBold IS NOT NULL
      OR p_rec_font.fItalic IS NOT NULL
      OR p_rec_font.fStrikeThrough IS NOT NULL
      OR p_rec_font.fPosition IS NOT NULL
      OR p_rec_font.fUnderline IS NOT NULL
    THEN
        put_line(
             p_clob
            ,'   <Font '||
            setName(p_rec_font.fName)||
            setFamily(p_rec_font.fFamily)||
            setSize(p_rec_font.fSize)||
            setColor(p_rec_font.fColor)||
            setEmphasis(p_rec_font.fBold,p_rec_font.fItalic,p_rec_font.fStrikeThrough)||
            setVerticalAlign(p_rec_font.fPosition)||
            setUnderline(p_rec_font.fUnderline)||
            ' />'
            );

    END IF;

END writeFont;

FUNCTION setBgPatternColor
    (
     p_value                IN VARCHAR2
    )
    RETURN VARCHAR2
IS
BEGIN

    IF p_value IS NOT NULL THEN
        RETURN ' ss:PatternColor="'||p_value||'" ';
    ELSE
        RETURN NULL;
    END IF;

END setBgPatternColor;

FUNCTION setBgPattern
    (
     p_value                IN VARCHAR2
    )
    RETURN VARCHAR2
IS
BEGIN

    IF p_value IS NOT NULL THEN
        RETURN ' ss:Pattern="'||p_value||'" ';
    ELSE
        RETURN NULL;
    END IF;

END setBgPattern;

PROCEDURE writeBackground
    (
     p_clob                 IN OUT NOCOPY CLOB
    ,p_rec_background       IN t_rec_background
    )
IS

BEGIN

    IF   p_rec_background.bColor IS NOT NULL
      OR p_rec_background.bPattern IS NOT NULL
      OR p_rec_background.bPatternColor IS NOT NULL
    THEN
        put_line(
             p_clob
            ,'   <Interior '||
            setColor(p_rec_background.bColor)||
            setBgPattern(p_rec_background.bPattern)||
            setBgPatternColor(p_rec_background.bPatternColor)||
            ' />'
            );
    END IF;
END writeBackground;

PROCEDURE writeNumberFormat
    (
     p_clob                 IN OUT NOCOPY CLOB
    ,p_type                 IN VARCHAR2
    ,p_format               IN VARCHAR2
    )
IS

BEGIN

    IF UPPER(p_format) <> 'TEXT' THEN
        put_line(p_clob,'   <NumberFormat ss:Format="'||p_format||'"/>');
    END IF;

END writeNumberFormat;

PROCEDURE writeProtection
    (
     p_clob                 IN OUT NOCOPY CLOB
    ,p_value                IN BOOLEAN
    )
IS

BEGIN

    put_line(p_clob,'   <Protection'||setProtected(p_value)||'/>');

END writeProtection;

FUNCTION setStyleName
    (
     p_value                IN VARCHAR2
    )
    RETURN VARCHAR2
IS
BEGIN

    IF p_value IS NOT NULL THEN
        RETURN ' ss:Name="'||p_value||'" ';
    ELSE
        RETURN NULL;
    END IF;

END setStyleName;

PROCEDURE writeStyles
    (
     p_clob                 IN OUT NOCOPY CLOB
    ,p_rec_style            IN t_rec_customStyles
    ,p_name                 IN VARCHAR2 := NULL
    )
IS
BEGIN
    pld('writeStyles');

        put_line(p_clob,'  <Style ss:ID="'||p_rec_style.id||'"'||setParent(p_rec_style.type)||setStyleName(p_name)||'>');
        writeAlign(p_clob,p_rec_style.alignment);
        writeBorders(p_clob,p_rec_style.border);
        writeFont(p_clob,p_rec_style.font);
        writeBackground(p_clob,p_rec_style.background);
        writeNumberFormat(p_clob,p_rec_style.type,p_rec_style.format);
        writeProtection(p_clob,p_rec_style.protection);
        put_line(p_clob,'  </Style>');

END writeStyles;

/*-----------------------------------------------------------------------------
||  Name:         writeCustomStyles
||  Description:  write the user defined styles part of the file header
||  Parameter:    p_clob - clob to write content from 'createNewFile'
||                p_tab_customStyles - user defined cell formats
-----------------------------------------------------------------------------*/
PROCEDURE writeCustomStyles
    (
     p_clob                 IN OUT NOCOPY CLOB
    ,p_tab_customStyles     IN t_tab_customStyles
    )
IS

BEGIN
    pld('writeCustomStyles');
    pld('. p_tab_customStyles.COUNT '||p_tab_customStyles.COUNT);

    FOR i IN p_tab_customStyles.FIRST .. p_tab_customStyles.LAST LOOP
        -- TODO pr？e ID auf Eindeutigkeit - interne PLSQL Tabelle
        writeStyles(p_clob,p_tab_customStyles(i));
    END LOOP;

END writeCustomStyles;

/*-----------------------------------------------------------------------------
||  Name:         writePredefinedStyles
||  Description:  write the styles part of the file header
||  Parameter:    p_clob - clob to write content from 'createNewFile'
||                p_tab_customStyles - user defined cell formats
-----------------------------------------------------------------------------*/
PROCEDURE writePredefinedStyles
    (
     p_clob                 IN OUT NOCOPY CLOB
    ,p_tab_customStyles     IN t_tab_customStyles
    ,p_globalCustomStyle    IN t_rec_customStyles
    )
IS
    r_style                 t_rec_customStyles;
BEGIN
    put_line(p_clob,' <Styles>');
    -- Default style
    r_style                     := p_globalCustomStyle;
    r_style.id                  := 'Default';
    r_style.type                := 'Text';
    r_style.protection          := p_globalCustomStyle.protection;
    r_style.alignment.vertical  := 'Top';
    r_style.alignment.horizontal := p_globalCustomStyle.alignment.horizontal;
    r_style.alignment.textRotate := p_globalCustomStyle.alignment.textRotate;
    r_style.alignment.readingOrder  := p_globalCustomStyle.alignment.readingOrder;
    r_style.alignment.shrinkToFit   := p_globalCustomStyle.alignment.shrinkToFit;
    r_style.alignment.verticalText  := p_globalCustomStyle.alignment.verticalText;
    r_style.alignment.wrapText  := p_globalCustomStyle.alignment.wrapText;
    r_style.background          := p_globalCustomStyle.background;
    r_style.border              := p_globalCustomStyle.border;
    r_style.font                := p_globalCustomStyle.font;
    r_style.font.fFamily        := NVL(p_globalCustomStyle.font.fFamily,'Swiss');
    writeStyles(p_clob,r_style,'Normal');

    -- Text
    r_style.id                  := c_textDefault;
    r_style.alignment.wrapText  := NVL(p_globalCustomStyle.alignment.wrapText,TRUE);
    writeStyles(p_clob,r_style);

    -- Bold
    r_style.id                  := c_textBold;
    r_style.font.fBold          := TRUE;
    writeStyles(p_clob,r_style);

    -- Underlined
    r_style.id                  := c_textUnderline;
    r_style.font.fBold          := FALSE;
    r_style.font.fUnderline     := 's';
    writeStyles(p_clob,r_style);

    --Bold Underlined
    r_style.id                  := c_textBoldUnderline;
    r_style.font.fBold          := TRUE;
    writeStyles(p_clob,r_style);

    -- Caption
    r_style.id                  := 'sh1';
    r_style.font.fUnderline     := NULL;
    r_style.border(1).bPosition := 'Top, Right, Bottom';
    r_style.border(1).bLineStyle := 'Continuous';
    r_style.border(1).bWeight   := 1;
    r_style.background.bColor   := c_silver;
    r_style.background.bPattern := c_bgpSolid;
    writeStyles(p_clob,r_style);
    --
    r_style.id                  := 'sh2';
    r_style.border(1).bPosition := 'Top, Right, Bottom, Left';
    writeStyles(p_clob,r_style);

    -- cell with number unformated
    put_line(p_clob,'  <Style ss:ID="'||c_unformatted||'">');
    --put_line(p_clob,'   <NumberFormat ss:Format="'||c_nfUnformatted||'"/>');
    put_line(p_clob,'  </Style>');
    -- cell with number unformated and Border top
    put_line(p_clob,'  <Style ss:ID="'||c_unformattedSum||'">');
    put_line(p_clob,'   <Borders>');
    put_line(p_clob,'    <Border ss:Position="Top" ss:LineStyle="Continuous" ss:Weight="1"/>');
    put_line(p_clob,'   </Borders>');
    put_line(p_clob,'  </Style>');
    -- cell with number, 2 decimal places and group separator
    put_line(p_clob,'  <Style ss:ID="'||c_numberDefault||'">');
    put_line(p_clob,'   <NumberFormat ss:Format="'||c_nf2decimalGroupSep||'"/>');
    put_line(p_clob,'  </Style>');
    -- cell with integer
    put_line(p_clob,'  <Style ss:ID="'||c_integer||'">');
   put_line(p_clob,'   <NumberFormat ss:Format="'||c_nfInteger||'"/>');
    put_line(p_clob,'  </Style>');
   -- cell with number, 2 decimal places
    put_line(p_clob,'  <Style ss:ID="'||c_number2decimal||'">');
    put_line(p_clob,'   <NumberFormat ss:Format="'||c_nf2decimal||'"/>');
    put_line(p_clob,'  </Style>');
   -- cell with number, 5 decimal places --add by Nathan 20160115
    put_line(p_clob,'  <Style ss:ID="'||c_number5decimal||'">');
    put_line(p_clob,'   <NumberFormat ss:Format="'||c_nf5decimal||'"/>');
    put_line(p_clob,'  </Style>');
   -- cell with Text, breakline --add by Ryan, 2017-01-26 
    put_line(p_clob,'  <Style ss:ID="'||c_textBreakLine ||'">');
    put_line(p_clob,'   <Alignment ss:Vertical="Top" ss:WrapText="1"/>');
    put_line(p_clob,'  </Style>');		
    --cell with currency format with two decimal places and red text with parenthesis for negative values
    put_line(p_clob,'  <Style ss:ID="'||c_currency||'">');
    put_line(p_clob,'   <NumberFormat ss:Format="'||c_nfCurrency||'"/>');
    put_line(p_clob,'  </Style>');
    -- same as c_currency using the Euro currency symbol instead
    put_line(p_clob,'  <Style ss:ID="'||c_accounting||'">');
    put_line(p_clob,'   <NumberFormat ss:Format="'||c_nfAccountingEur||'"/>');
    put_line(p_clob,'  </Style>');
    -- cell with number as percent
    put_line(p_clob,'  <Style ss:ID="'||c_prozent||'" ss:Name="Prozent">');
    put_line(p_clob,'   <NumberFormat ss:Format="'||c_nfPercent||'"/>');
    put_line(p_clob,'  </Style>');
    -- cell with number as percent and 2 decimal numbers
    put_line(p_clob,'  <Style ss:ID="'||c_percent2decimal||'" ss:Parent="'||c_prozent||'">');
    put_line(p_clob,'   <NumberFormat ss:Format="Percent"/>');
    put_line(p_clob,'  </Style>');
    -- cell with date
    put_line(p_clob,'  <Style ss:ID="'||c_date||'">');
    put_line(p_clob,'   <NumberFormat ss:Format="'||c_dfDDMMYYYY||'"/>');
    put_line(p_clob,'  </Style>');
    -- cell with datetime
    put_line(p_clob,'  <Style ss:ID="'||c_dateTime||'">');
    put_line(p_clob,'   <NumberFormat ss:Format="'||c_dfDDMMYYYYHHMI||'"/>');
    put_line(p_clob,'  </Style>');

    IF p_tab_customStyles.COUNT > 0 THEN
        writeCustomStyles(p_clob,p_tab_customStyles);
    END IF;
    put_line(p_clob,' </Styles>');
END writePredefinedStyles;

PROCEDURE writeFileHeader
    (
     p_clob                 IN OUT NOCOPY CLOB
    ,p_encoding             IN VARCHAR2
    )
IS

BEGIN
    -- Header
    put_line(p_clob,'<?xml version="1.0" encoding="'||p_encoding||'"?>');
    put_line(p_clob,'<?mso-application progid="Excel.Sheet"?>');
    put_line(p_clob,'<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet"');
    put_line(p_clob,' xmlns:o="urn:schemas-microsoft-com:office:office"');
    put_line(p_clob,' xmlns:x="urn:schemas-microsoft-com:office:excel"');
    put_line(p_clob,' xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet"');
    put_line(p_clob,' xmlns:html="http://www.w3.org/TR/REC-html40">');
    put_line(p_clob,' <DocumentProperties xmlns="urn:schemas-microsoft-com:office:office">');
    put_line(p_clob,'  <Author>'||SYS_CONTEXT ('USERENV', 'OS_USER')||'</Author>');
    put_line(p_clob,'  <LastAuthor>'||SYS_CONTEXT ('USERENV', 'OS_USER')||'</LastAuthor>');
    put_line(p_clob,'  <Created>'||convertDateIntoExcelFormat(SYSDATE)||'</Created>');
--  put_line(p_clob,'  <Company></Company>');
    put_line(p_clob,' </DocumentProperties>');
END writeFileHeader;

/*-----------------------------------------------------------------------------
||  Name:         createNewFile
||  Description:  create a new Excel file
||  Parameter:    p_path - valid DIRECTORY_NAME from database
||                p_filename - file name
||                p_tab_customStyles - user defined cell formats
||                p_globalCustomStyle - Set a global default cell format
||  @param        p_encoding - Character encoding like UTF-8, UTF-16. DEFAULT windows-1252
-----------------------------------------------------------------------------*/
FUNCTION createNewFile
    (
     p_path                 IN VARCHAR2
    ,p_filename             IN VARCHAR2
    ,p_tab_customStyles     IN t_tab_customStyles := g_tab_customStyles
    ,p_globalCustomStyle    IN t_rec_customStyles := g_rec_customStyles
    ,p_encoding             IN VARCHAR2     DEFAULT 'UTF-8'
    )
    RETURN utl_file.FILE_TYPE
IS
    v_clob                  CLOB;
    v_fileHandle            utl_file.FILE_TYPE;
    v_argsstr               VARCHAR2(500)   := SUBSTR(
                                                'p_path '||p_path||','||
                                                'p_filename '||p_filename
                                                ,1,500);

BEGIN
    g_apps := 'N';
    pld('createNewFile File g_apps:'||g_apps);
    
    checkPath(p_path);

    -- open file
    v_fileHandle    := fopen(p_path, p_filename);

    dbms_lob.createTemporary(v_clob,TRUE);

    createNewFile(
         p_file               => v_clob
        ,p_tab_customStyles   => p_tab_customStyles
        ,p_globalCustomStyle  => p_globalCustomStyle
        ,p_encoding           => p_encoding);
    put_data(v_fileHandle, v_clob);

    dbms_lob.freeTemporary(v_clob);

    RETURN v_fileHandle;

EXCEPTION
    WHEN e_invalidPath THEN
        RAISE_APPLICATION_ERROR(
             -20001
            ,'Error in '||c_packageName||'.createNewFile: ' ||
             v_argsstr ||' ' ||
             'invalid path'
             );
END createNewFile;

/**
||  @Name         createNewFile_Apps
||  @Description  Set "g_ebs" to 'Y' and return fnd_file.output number ,just makesue that fnd_file can be use . 
||  @param        p_filename - file name
||  @param        p_tab_customStyles - user defined cell formats
||  @param        p_globalCustomStyle - Set a global default cell format
||  @param        p_encoding - Character encoding like UTF-8, UTF-16. DEFAULT UTF-8
*/
FUNCTION createNewFile_Apps
    (p_tab_customStyles     IN t_tab_customStyles := g_tab_customStyles
    ,p_globalCustomStyle    IN t_rec_customStyles := g_rec_customStyles
    ,p_encoding             IN VARCHAR2     DEFAULT 'UTF-8'
    )
    RETURN number 
IS    
    v_clob                  CLOB;    
    p_AppsfileHandle        NUMBER;
BEGIN
   g_apps := 'Y';
   pld('createNewFile_Apps File g_apps:' ||g_apps);
   p_AppsfileHandle := fnd_file.output;
    dbms_lob.createTemporary(v_clob,TRUE);
        
    convert_ebs_encode(g_encode);
    
    createNewFile(
         p_file               => v_clob
        ,p_tab_customStyles   => p_tab_customStyles
        ,p_globalCustomStyle  => p_globalCustomStyle
        ,p_encoding           => g_encode);
  
     put_data(p_AppsfileHandle, v_clob);
    dbms_lob.freeTemporary(v_clob);   
   RETURN p_AppsfileHandle;

EXCEPTION
    WHEN others THEN
        RAISE_APPLICATION_ERROR(
             -20001
            ,'Error in '||c_packageName||'.createNewFile_App: ' || SQLERRM
             );   
END createNewFile_Apps;    

PROCEDURE createNewFile
    (
     p_file                 IN OUT NOCOPY CLOB
    ,p_tab_customStyles     IN t_tab_customStyles := g_tab_customStyles
    ,p_globalCustomStyle    IN t_rec_customStyles := g_rec_customStyles
    ,p_encoding             IN VARCHAR2     DEFAULT 'UTF-8'
    )
IS
BEGIN
    pld('createNewFile CLOB');
    writeFileHeader(p_file,p_encoding );
    writePredefinedStyles(p_file,p_tab_customStyles,p_globalCustomStyle);
END createNewFile;

PROCEDURE writeNewDataRow
    (
     p_clob                 IN OUT NOCOPY CLOB
    ,p_format               IN VARCHAR2
    ,p_height               IN PLS_INTEGER
    ,p_index                IN PLS_INTEGER
    ,p_closeRow             IN BOOLEAN
    )
IS

BEGIN
    pld('writeNewDataRow');
    pld('. p_index '||p_index);
    IF p_closeRow THEN
        put_line(p_clob,'   </Row>');
    END IF;

    put_line(p_clob,'   <Row ss:AutoFitHeight="1"'||setIndex(p_index)||setFormat(p_format)||setHeight(p_height)||'>');

END writeNewDataRow;

/*-----------------------------------------------------------------------------
||  Name:         newDataRow
||  Description:  close previous row and open a new one
||  Parameter:    p_clob - clob to write content 'createNewFile'
||                p_format - Formatting of the cells according to constants
||                  in package header or user defines formats.
||                p_height - Row height in pt
||                p_index - Row index: Specifies the position of this row within
||                  the table. If this tag is not specified, the first instance
||                  has an assumed Index="1". Each additional Row element has an
||                  assumed Index that is one higher. Indices must appear in
||                  strictly increasing order. Failure to do so will result in
||                  an XML Spreadsheet document that is invalid. Indices do not
||                  need to be sequential, however. Omitted indices are formatted
||                  with the default style's format.
||                p_closeRow - Close previous data row before opening the new one.
||                  Set to FALSE for the first row when the worksheet is opend
||                  with p_beginNewRow = FALSE
-----------------------------------------------------------------------------*/
PROCEDURE newDataRow
    (
     p_fileHandle           IN utl_file.FILE_TYPE
    ,p_format               IN VARCHAR2 := NULL
    ,p_height               IN PLS_INTEGER := NULL
    ,p_index                IN PLS_INTEGER := NULL
    ,p_closeRow             IN BOOLEAN := TRUE
    )
IS
    v_clob                  CLOB;    
BEGIN
    dbms_lob.createTemporary(v_clob,TRUE);

    writeNewDataRow(
         v_clob
        ,p_format
        ,p_height
        ,p_index
        ,p_closeRow
        );
    if g_apps ='N' then      
      put_data(p_fileHandle, v_clob);
    else
      put_data(fnd_file.output, v_clob);
    end if;  

    dbms_lob.freeTemporary(v_clob);

END newDataRow;





PROCEDURE newDataRow
    (
     p_file                 IN OUT NOCOPY CLOB
    ,p_format               IN VARCHAR2 := NULL
    ,p_height               IN PLS_INTEGER := NULL
    ,p_index                IN PLS_INTEGER := NULL
    ,p_closeRow             IN BOOLEAN := TRUE
    )
IS
BEGIN
    writeNewDataRow(
         p_file
        ,p_format
        ,p_height
        ,p_index
        ,p_closeRow
        );
END newDataRow;

/*-----------------------------------------------------------------------------
||  Name:         setStyle
||  Description:  Set cell style
||  Parameter:    p_format - format
-----------------------------------------------------------------------------*/
FUNCTION setStyle
    (
     p_format                IN VARCHAR2
    )
    RETURN VARCHAR2
IS
BEGIN
    IF p_format IS NULL THEN
        RETURN NULL;
    ELSE
        RETURN 'ss:StyleID="'||p_format||'" ';
    END IF;

END setStyle;

PROCEDURE writeVarcharData
    (
     p_clob                 IN OUT NOCOPY CLOB
    ,p_text                 IN VARCHAR2
    ,p_format               IN VARCHAR2
    ,p_comment              IN VARCHAR2
    ,p_formula              IN VARCHAR2
    ,p_colspan              IN PLS_INTEGER
    ,p_href                 IN VARCHAR2
    ,p_index                IN PLS_INTEGER
    ,p_protected            IN BOOLEAN
    )
IS
BEGIN

    put_line(
             p_clob
            ,'    <Cell '||setProtected(p_protected)||setIndex(p_index)||setURL(p_href)||setColspan(p_colspan)||setStyle(p_format)||formatFormula(p_formula)||'>'||
             '<Data ss:Type="String">'||escapeSpecialCharacters(p_text)||'</Data>'||
             formatComment(p_comment)||
             '</Cell>'
            );

END writeVarcharData;

/*-----------------------------------------------------------------------------
||  Name:         writeData
||  Description:  write text
||  Parameter:    p_fileHandle - file handle from 'createNewFile'
||                p_text - string to be written
||                p_format - Formatting of the text according to constants
||                  in package header.
||                p_comment - comment.
||                p_formula - The cells are referenced relative to the formula cell
||                  The syntax is e.g.
||                       =SUM(R[-2]C,R[-1]C)
||                       =IF(B6>0;"T";"U")
||                       =AVERAGE(R[-2]C:R[-1]C)
||                       =COUNT(R[-2]C:R[-1]C)
||                p_colspan - Merge cells horizontally.
||                p_href - URL to which to link this cell.
||                p_index - column index within containing row.
||                  Indices must appear in strictly increasing order
||                  Indices must not overlap
||                p_protected - indicates whether or not this cell is protected.
||                  When the worksheet is unprotected, cell-level protection has
||                  no effect. When a cell is protected, it will not allow the
||                  user to enter information into it.
-----------------------------------------------------------------------------*/
PROCEDURE writeData
    (
     p_fileHandle           IN utl_file.FILE_TYPE
    ,p_text                 IN VARCHAR2
    ,p_format               IN VARCHAR2 := NULL
    ,p_comment              IN VARCHAR2 := NULL
    ,p_formula              IN VARCHAR2 := NULL
    ,p_colspan              IN PLS_INTEGER := NULL
    ,p_href                 IN VARCHAR2 := NULL
    ,p_index                IN PLS_INTEGER := NULL
    ,p_protected            IN BOOLEAN  := NULL
    )
IS
    v_clob                  clob;
BEGIN
    dbms_lob.createTemporary(v_clob,TRUE);

    writeVarcharData(
         v_clob
        ,p_text
        ,p_format
        ,p_comment
        ,p_formula
        ,p_colspan
        ,p_href
        ,p_index
        ,p_protected
        );
    if g_apps ='N' then      
      put_data(p_fileHandle, v_clob);
    else
      put_data(fnd_file.output, v_clob);
    end if;  

    dbms_lob.freeTemporary(v_clob);

END writeData;

PROCEDURE writeData
    (
     p_file                 IN OUT NOCOPY CLOB
    ,p_text                 IN VARCHAR2
    ,p_format               IN VARCHAR2 := NULL
    ,p_comment              IN VARCHAR2 := NULL
    ,p_formula              IN VARCHAR2 := NULL
    ,p_colspan              IN PLS_INTEGER := NULL
    ,p_href                 IN VARCHAR2 := NULL
    ,p_index                IN PLS_INTEGER := NULL
    ,p_protected            IN BOOLEAN  := NULL
    )
IS

BEGIN
    writeVarcharData(
         p_file
        ,p_text
        ,p_format
        ,p_comment
        ,p_formula
        ,p_colspan
        ,p_href
        ,p_index
        ,p_protected
        );
END writeData;

PROCEDURE writeNumberData
    (
     p_clob                 IN OUT NOCOPY CLOB
    ,p_number               IN NUMBER
    ,p_format               IN VARCHAR2
    ,p_comment              IN VARCHAR2
    ,p_formula              IN VARCHAR2
    ,p_colspan              IN PLS_INTEGER
    ,p_href                 IN VARCHAR2
    ,p_index                IN PLS_INTEGER
    ,p_protected            IN BOOLEAN
    )
IS

BEGIN

    put_line(
             p_clob
            ,'    <Cell '||setProtected(p_protected)||setIndex(p_index)||setURL(p_href)||setColspan(p_colspan)||setStyle(p_format)||formatFormula(p_formula)||'>'||
             '<Data ss:Type="Number">'||convertNumberIntoExcelFormat(p_number)||'</Data>'||
             formatComment(p_comment)||
             '</Cell>'
            );

END writeNumberData;

/*-----------------------------------------------------------------------------
||  Name:         writeData
||  Description:  write number
||  Parameter:    p_clob - clob to write content from 'createNewFile'
||                p_number - number to be written
||                p_format - Formatting of the number Values according to constants
||                  in package header.
||                p_comment - comment.
||                p_formula - The cells are referenced relative to the formula cell
||                  The syntax is e.g.
||                       =SUM(R[-2]C,R[-1]C)
||                       =IF(B6>0;"T";"U")
||                       =AVERAGE(R[-2]C:R[-1]C)
||                       =COUNT(R[-2]C:R[-1]C)
||                p_colspan - Merge cells horizontally.
||                p_href - URL to which to link this cell.
||                p_index - column index within containing row.
||                  Indices must appear in strictly increasing order
||                  Indices must not overlap
||                p_protected - indicates whether or not this cell is protected.
||                  When the worksheet is unprotected, cell-level protection has
||                  no effect. When a cell is protected, it will not allow the
||                  user to enter information into it.
-----------------------------------------------------------------------------*/
PROCEDURE writeData
    (
     p_fileHandle           IN utl_file.FILE_TYPE
    ,p_number               IN NUMBER
    ,p_format               IN VARCHAR2 := NULL
    ,p_comment              IN VARCHAR2 := NULL
    ,p_formula              IN VARCHAR2 := NULL
    ,p_colspan              IN PLS_INTEGER := NULL
    ,p_href                 IN VARCHAR2 := NULL
    ,p_index                IN PLS_INTEGER := NULL
    ,p_protected            IN BOOLEAN  := NULL
    )
IS
     v_clob                  CLOB;
BEGIN

    dbms_lob.createTemporary(v_clob,TRUE);

    writeNumberData(
         v_clob
        ,p_number
        ,p_format
        ,p_comment
        ,p_formula
        ,p_colspan
        ,p_href
        ,p_index
        ,p_protected
        );

    if g_apps ='N' then      
      put_data(p_fileHandle, v_clob);
    else
      put_data(fnd_file.output, v_clob);
    end if;  

    dbms_lob.freeTemporary(v_clob);

END writeData;

PROCEDURE writeData
    (
     p_file                 IN OUT NOCOPY CLOB
    ,p_number               IN NUMBER
    ,p_format               IN VARCHAR2 := NULL
    ,p_comment              IN VARCHAR2 := NULL
    ,p_formula              IN VARCHAR2 := NULL
    ,p_colspan              IN PLS_INTEGER := NULL
    ,p_href                 IN VARCHAR2 := NULL
    ,p_index                IN PLS_INTEGER := NULL
    ,p_protected            IN BOOLEAN  := NULL
    )
IS

BEGIN

    writeNumberData(
         p_file
        ,p_number
        ,p_format
        ,p_comment
        ,p_formula
        ,p_colspan
        ,p_href
        ,p_index
        ,p_protected
        );

END writeData;

PROCEDURE writeDateData
    (
     p_clob                 IN OUT NOCOPY CLOB
    ,p_date                 IN DATE
    ,p_format               IN VARCHAR2
    ,p_comment              IN VARCHAR2
    ,p_formula              IN VARCHAR2
    ,p_colspan              IN PLS_INTEGER
    ,p_href                 IN VARCHAR2
    ,p_index                IN PLS_INTEGER
    ,p_protected            IN BOOLEAN
    )
IS

BEGIN
    IF p_date IS NULL THEN
        put_line(
                 p_clob
                ,'    <Cell '||setProtected(p_protected)||setIndex(p_index)||setURL(p_href)||setColspan(p_colspan)||setStyle(NVL(p_format,c_date))||formatFormula(p_formula)||'>'||
                 formatComment(p_comment)||
                 '</Cell>'
                );
    -- Dates before 01.01.1900 cannot be displayed by Excel therefore they are written as Text
    -- System nls_date_format is used
    ELSIF p_date < TO_DATE('01.01.1900','dd.mm.yyyy') THEN
        writeVarcharData(
             p_clob
            ,TO_CHAR(p_date)
            ,c_textDefault
            ,p_comment
            ,NULL
            ,p_colspan
            ,p_href
            ,p_index
            ,p_protected
            );
    ELSE
        put_line(
                 p_clob
                ,'    <Cell '||setProtected(p_protected)||setIndex(p_index)||setURL(p_href)||setColspan(p_colspan)||setStyle(NVL(p_format,c_date))||formatFormula(p_formula)||'>'||
                 '<Data ss:Type="DateTime">'||convertDateIntoExcelFormat(p_date)||'</Data>'||
                 formatComment(p_comment)||
                 '</Cell>'
                );
    END IF;

END writeDateData;

/*-----------------------------------------------------------------------------
||  Name:         writeData
||  Description:  write date
||  Parameter:    p_clob - clob to write content from 'createNewFile'
||                p_date - date to be written
||                p_format - Formatting of the date values according to constants
||                  in package header.
||                p_comment - comment.
||                p_formula - The cells are referenced relative to the formula cell
||                  The syntax is e.g.
||                       =SUM(R[-2]C,R[-1]C)
||                       =IF(B6>0;"T";"U")
||                       =AVERAGE(R[-2]C:R[-1]C)
||                       =COUNT(R[-2]C:R[-1]C)
||                p_colspan - Merge cells horizontally.
||                p_href - URL to which to link this cell.
||                p_index - column index within containing row.
||                  Indices must appear in strictly increasing order
||                  Indices must not overlap
||                p_protected - indicates whether or not this cell is protected.
||                  When the worksheet is unprotected, cell-level protection has
||                  no effect. When a cell is protected, it will not allow the
||                  user to enter information into it.
-----------------------------------------------------------------------------*/
PROCEDURE writeData
    (
     p_fileHandle           IN utl_file.FILE_TYPE
    ,p_date                 IN DATE
    ,p_format               IN VARCHAR2 := NULL
    ,p_comment              IN VARCHAR2 := NULL
    ,p_formula              IN VARCHAR2 := NULL
    ,p_colspan              IN PLS_INTEGER := NULL
    ,p_href                 IN VARCHAR2 := NULL
    ,p_index                IN PLS_INTEGER := NULL
    ,p_protected            IN BOOLEAN  := NULL
    )
IS
     v_clob                  clob;
BEGIN
    dbms_lob.createTemporary(v_clob,TRUE);

    writeDateData(
         v_clob
        ,p_date
        ,p_format
        ,p_comment
        ,p_formula
        ,p_colspan
        ,p_href
        ,p_index
        ,p_protected
        );

    if g_apps ='N' then      
      put_data(p_fileHandle, v_clob);
    else
      put_data(fnd_file.output, v_clob);
    end if;  

    dbms_lob.freeTemporary(v_clob);

END writeData;

PROCEDURE writeData
    (
     p_file                 IN OUT NOCOPY CLOB
    ,p_date                 IN DATE
    ,p_format               IN VARCHAR2 := NULL
    ,p_comment              IN VARCHAR2 := NULL
    ,p_formula              IN VARCHAR2 := NULL
    ,p_colspan              IN PLS_INTEGER := NULL
    ,p_href                 IN VARCHAR2 := NULL
    ,p_index                IN PLS_INTEGER := NULL
    ,p_protected            IN BOOLEAN  := NULL
    )
IS

BEGIN
    writeDateData(
         p_file
        ,p_date
        ,p_format
        ,p_comment
        ,p_formula
        ,p_colspan
        ,p_href
        ,p_index
        ,p_protected
        );

END writeData;

FUNCTION centi2inch
    (
     p_centimeter           IN NUMBER
    )
    RETURN VARCHAR2
IS

BEGIN
    RETURN convertNumberIntoExcelFormat(p_centimeter / 254 * 100);
END centi2inch;

FUNCTION replaceMarginText
    (
     p_text                 IN VARCHAR2
    )
    RETURN VARCHAR2
IS

BEGIN
    pld('replaceMarginText');

    RETURN  REPLACE(
             REPLACE(
              REPLACE(
               REPLACE(
                REPLACE(
                 REPLACE(
                  REPLACE(
                   REPLACE(
                    REPLACE(
                     REPLACE(
                      REPLACE(
                       REPLACE(
                        REPLACE(
                         REPLACE(
                          REPLACE(
                           escapeSpecialCharacters( p_text)
                           ,c_mtFontSize8,CHR(38)||'amp;8')
                          ,c_mtFontSize10,CHR(38)||'amp;10')
                         ,c_mtFontSize12,CHR(38)||'amp;12')
                        ,c_mtFontSize14,CHR(38)||'amp;14')
                       ,c_mtFontStandard,CHR(38)||'amp;'||CHR(38)||'quot;Arial,Standard'||CHR(38)||'quot;')
                      ,c_mtFontBold,CHR(38)||'amp;'||CHR(38)||'quot;Arial,Fett'||CHR(38)||'quot;')
                     ,c_mtFontItalic,CHR(38)||'amp;'||CHR(38)||'quot;Arial,Kursiv'||CHR(38)||'quot;')
                    ,c_mtFontBoldItalic,CHR(38)||'amp;'||CHR(38)||'quot;Arial,Fett Kursiv'||CHR(38)||'quot;')
                   ,c_mtPage,CHR(38)||'amp;S')
                  ,c_mtPageTotal, CHR(38)||'amp;A')
                 ,c_mtTime, CHR(38)||'amp;U')
                ,c_mtDate, CHR(38)||'amp;D')
               ,c_mtPath, CHR(38)||'amp;P')
              ,c_mtName, CHR(38)||'amp;N')
             ,c_mtTab, CHR(38)||'amp;B');

END replaceMarginText;

PROCEDURE writePrintSetup
    (
     p_clob                 IN OUT NOCOPY CLOB
    ,p_rec_printSetup       IN t_rec_printSetup
    )
IS
BEGIN
    put_line(p_clob,'   <PageSetup>');

    IF p_rec_printSetup.landscape THEN
        put_line(p_clob,'    <Layout x:Orientation="Landscape"/>');
    END IF;

    IF p_rec_printSetup.headerLeft IS NOT NULL
      OR p_rec_printSetup.headerCenter IS NOT NULL
      OR p_rec_printSetup.headerRight IS NOT NULL
    THEN
        put_line(
             p_clob
            ,'    <Header x:Margin="'||centi2inch(NVL(p_rec_printSetup.headerMargin,13/10))||'" '||
             'x:Data="'||CHR(38)||'amp;L'||replaceMarginText(p_rec_printSetup.headerLeft)||' '||
             ''||CHR(38)||'amp;Z'||replaceMarginText(p_rec_printSetup.headerCenter)||' '||
             ''||CHR(38)||'amp;R'||replaceMarginText(p_rec_printSetup.headerRight)||' "/>'
             );
    END IF;

    IF p_rec_printSetup.footerLeft IS NOT NULL
      OR p_rec_printSetup.footerCenter IS NOT NULL
      OR p_rec_printSetup.footerRight IS NOT NULL
    THEN
        put_line(
             p_clob
            ,'    <Footer x:Margin="'||centi2inch(NVL(p_rec_printSetup.footerMargin,13/10))||'" '||
             'x:Data="'||CHR(38)||'amp;L'||replaceMarginText(p_rec_printSetup.footerLeft)||' '||
             ''||CHR(38)||'amp;Z'||replaceMarginText(p_rec_printSetup.footerCenter)||' '||
             ''||CHR(38)||'amp;R'||replaceMarginText(p_rec_printSetup.footerRight)||' "/>'
             );
    END IF;

    put_line(
         p_clob
        ,'    <PageMargins x:Bottom="'||centi2inch(NVL(p_rec_printSetup.pageMarginBottom,25/10))||'" '||
         'x:Left="'||centi2inch(NVL(p_rec_printSetup.pageMarginLeft,25/10))||'" '||
         'x:Right="'||centi2inch(NVL(p_rec_printSetup.pageMarginRight,25/10))||'" '||
         'x:Top="'||centi2inch(NVL(p_rec_printSetup.pageMarginTop,25/10))||'"/>'
         );

    put_line(p_clob,'   </PageSetup>');

END writePrintSetup;

PROCEDURE writeCloseWorksheet
    (
     p_clob                 IN OUT NOCOPY CLOB
    ,p_lineFixed            IN PLS_INTEGER
    ,p_colFixed             IN PLS_INTEGER
    ,p_tab_caption          IN t_tab_caption
    ,p_autofilter           IN BOOLEAN
    ,p_tab_conditionalFormats IN t_tab_conditionalFormats
    ,p_rec_printSetup       IN t_rec_printSetup
    ,p_rec_autofilter       IN t_rec_autofilter
    )
IS

BEGIN
    put_line(p_clob,'   </Row>');
    put_line(p_clob,'  </Table>');
    -- Worksheet to be closed
    put_line(p_clob,'  <WorksheetOptions xmlns="urn:schemas-microsoft-com:office:excel">');
    put_line(p_clob,'   <Selected/>');
    -- Print output in landscape format
    writePrintSetup(p_clob,p_rec_printSetup);
    -- Fix first n lines when scrolling
    IF   p_lineFixed > 0
      AND p_colFixed = 0
    THEN
        put_line(p_clob,'   <FreezePanes/>');
        put_line(p_clob,'   <FrozenNoSplit/>');
        put_line(p_clob,'   <SplitHorizontal>'||p_lineFixed||'</SplitHorizontal>');
        put_line(p_clob,'   <TopRowBottomPane>'||p_lineFixed||'</TopRowBottomPane>');
        put_line(p_clob,'   <ActivePane>2</ActivePane>');
        put_line(p_clob,'   <Panes>');
        put_line(p_clob,'    <Pane>');
        put_line(p_clob,'     <Number>3</Number>');
        put_line(p_clob,'    </Pane>');
        put_line(p_clob,'    <Pane>');
        put_line(p_clob,'     <Number>2</Number>');
        put_line(p_clob,'    </Pane>');
        put_line(p_clob,'   </Panes>');
    ELSIF p_lineFixed = 0
      AND p_colFixed > 0
    THEN
        put_line(p_clob,'   <FreezePanes/>');
        put_line(p_clob,'   <FrozenNoSplit/>');
        put_line(p_clob,'   <SplitVertical>'||p_colFixed||'</SplitVertical>');
        put_line(p_clob,'   <LeftColumnRightPane>'||p_colFixed||'</LeftColumnRightPane>');
        put_line(p_clob,'   <ActivePane>1</ActivePane>');
        put_line(p_clob,'   <Panes>');
        put_line(p_clob,'    <Pane>');
        put_line(p_clob,'     <Number>3</Number>');
        put_line(p_clob,'    </Pane>');
        put_line(p_clob,'    <Pane>');
        put_line(p_clob,'     <Number>1</Number>');
        put_line(p_clob,'     <ActiveRow>1</ActiveRow>');
        put_line(p_clob,'     <ActiveCol>0</ActiveCol>');
        put_line(p_clob,'    </Pane>');
        put_line(p_clob,'   </Panes>');
    ELSIF p_lineFixed > 0
      AND p_colFixed > 0
    THEN
        put_line(p_clob,'   <FreezePanes/>');
        put_line(p_clob,'   <FrozenNoSplit/>');
        put_line(p_clob,'   <SplitHorizontal>'||p_lineFixed||'</SplitHorizontal>');
        put_line(p_clob,'   <TopRowBottomPane>'||p_lineFixed||'</TopRowBottomPane>');
        put_line(p_clob,'   <SplitVertical>'||p_colFixed||'</SplitVertical>');
        put_line(p_clob,'   <LeftColumnRightPane>'||p_colFixed||'</LeftColumnRightPane>');
        put_line(p_clob,'   <ActivePane>0</ActivePane>');
        put_line(p_clob,'   <Panes>');
        put_line(p_clob,'    <Pane>');
        put_line(p_clob,'     <Number>3</Number>');
        put_line(p_clob,'    </Pane>');
        put_line(p_clob,'    <Pane>');
        put_line(p_clob,'     <Number>1</Number>');
        put_line(p_clob,'    </Pane>');
        put_line(p_clob,'    <Pane>');
        put_line(p_clob,'     <Number>2</Number>');
        put_line(p_clob,'    </Pane>');
        put_line(p_clob,'    <Pane>');
        put_line(p_clob,'     <Number>0</Number>');
        put_line(p_clob,'    </Pane>');
        put_line(p_clob,'   </Panes>');
    ELSE
        put_line(p_clob,'   <Panes>');
        put_line(p_clob,'    <Pane>');
        put_line(p_clob,'     <Number>3</Number>');
        put_line(p_clob,'     <ActiveRow>1</ActiveRow>');
        put_line(p_clob,'    </Pane>');
        put_line(p_clob,'   </Panes>');

    END IF;
    put_line(p_clob,'   <ProtectObjects>False</ProtectObjects>');
    put_line(p_clob,'   <ProtectScenarios>False</ProtectScenarios>');
    put_line(p_clob,'  </WorksheetOptions>');

    writeAutofilter(p_clob,p_tab_caption,p_rec_autofilter,p_autofilter);
    writeConditionalFormatting(p_clob,p_tab_conditionalFormats);

    put_line(p_clob,' </Worksheet>');

END writeCloseWorksheet;
/**
||  @Name         closeWorksheet
||  @Description  close last data row and close worksheet
||  @param        p_file - CLOB
||  @param        p_lineFixed - is the n-th line to be fixed when scrolling
||                  within the last worksheet
||                  0 = not fixed
||  @param        p_colFixed - is the n-th column to be fixed when scrolling
||                  within the last worksheet
||                  0 = not fixed
||  @param        p_tab_caption - collection with caption information
||  @param        p_autofilter - Set autofilter TRUE = Yes
||  @param        p_tab_conditionalFormats - collection with formatting information
||  @param        p_rec_printSetup - format for printing
||  @param        p_rec_autofilter - custom autofilter
*/
PROCEDURE closeWorksheet
    (
     p_fileHandle           IN utl_file.FILE_TYPE
    ,p_lineFixed            IN PLS_INTEGER := 1
    ,p_colFixed             IN PLS_INTEGER := 0
    ,p_tab_caption          IN t_tab_caption := g_tab_caption
    ,p_autofilter           IN BOOLEAN := TRUE
    ,p_tab_conditionalFormats IN t_tab_conditionalFormats := g_tab_conditionalFormats
    ,p_rec_printSetup       IN t_rec_printSetup := g_rec_printSetup
    ,p_rec_autofilter       IN t_rec_autofilter := g_rec_autofilter
    )
IS
     v_clob                  CLOB;
BEGIN
    pld('closeWorksheet File');

    dbms_lob.createTemporary(v_clob,TRUE);

    writeCloseWorksheet(
         v_clob
        ,p_lineFixed
        ,p_colFixed
        ,p_tab_caption
        ,p_autofilter
        ,p_tab_conditionalFormats
        ,p_rec_printSetup
        ,p_rec_autofilter
        );

    if g_apps ='N' then      
      put_data(p_fileHandle, v_clob);
    else
      put_data(fnd_file.output, v_clob);
    end if;  

    dbms_lob.freeTemporary(v_clob);

END closeWorksheet;

/**
||  @Name         closeWorksheet
||  @Description  close last data row and close worksheet
||  @param        p_file - CLOB
||  @param        p_lineFixed - is the n-th line to be fixed when scrolling
||                  within the last worksheet
||                  0 = not fixed
||  @param        p_colFixed - is the n-th column to be fixed when scrolling
||                  within the last worksheet
||                  0 = not fixed
||  @param        p_tab_caption - collection with caption information
||  @param        p_autofilter - Set autofilter TRUE = Yes
||  @param        p_tab_conditionalFormats - collection with formatting information
||  @param        p_rec_printSetup - format for printing
||  @param        p_rec_autofilter - custom autofilter
*/
PROCEDURE closeWorksheet
    (
     p_file                 IN OUT NOCOPY CLOB
    ,p_lineFixed            IN PLS_INTEGER := 1
    ,p_colFixed             IN PLS_INTEGER := 0
    ,p_tab_caption          IN t_tab_caption := g_tab_caption
    ,p_autofilter           IN BOOLEAN := TRUE
    ,p_tab_conditionalFormats IN t_tab_conditionalFormats := g_tab_conditionalFormats
    ,p_rec_printSetup       IN t_rec_printSetup := g_rec_printSetup
    ,p_rec_autofilter       IN t_rec_autofilter := g_rec_autofilter
    )
IS
BEGIN
    pld('closeWorksheet CLOB');

    writeCloseWorksheet(
         p_file
        ,p_lineFixed
        ,p_colFixed
        ,p_tab_caption
        ,p_autofilter
        ,p_tab_conditionalFormats
        ,p_rec_printSetup
        ,p_rec_autofilter
        );
END closeWorksheet;

PROCEDURE writeNewWorksheet
    (
     p_clob                 IN OUT NOCOPY CLOB
    ,p_sheetname            IN VARCHAR2
    ,p_tab_caption          IN t_tab_caption
    ,p_tab_columns          IN t_tab_columns
    ,p_format               IN VARCHAR2
    ,p_height               IN PLS_INTEGER
    ,p_protected            IN BOOLEAN
    ,p_beginNewRow          IN BOOLEAN
    ,p_rec_printSetup       IN t_rec_printSetup
    )
IS

BEGIN

    --New Worksheet
    put_line(p_clob,' <Worksheet ss:Name="'||escapeSpecialCharacters(p_sheetname)||'"'||setProtected(p_protected)||'>');

    IF p_tab_caption.COUNT > 0
      OR p_rec_printSetup.printTitle IS NOT NULL
      OR p_rec_printSetup.printArea IS NOT NULL
    THEN
        writeNamedRange(p_clob,p_tab_caption,p_rec_printSetup,p_sheetname);
    END IF;

    put_line(p_clob,'  <Table ss:DefaultColumnWidth="60">');

    IF p_tab_columns.COUNT > 0 THEN
        writeColumns(p_clob,p_tab_columns);
    END IF;

    IF p_tab_caption.COUNT > 0 THEN
        writeCaption(p_clob,p_tab_caption);
    END IF;

    IF p_beginNewRow THEN
        put_line(p_clob,'   <Row ss:AutoFitHeight="1"'||setFormat(p_format)||setHeight(p_height)||'>');
    END IF;

END writeNewWorksheet;

/**
||  @Name         newWorksheet
||  @Description  open a new worksheet and open first data row
||  @param        p_fileHandle - file handle from 'createNewFile'
||  @param        p_sheetname - name of the first worksheet.
||                  This name has to be unique within the file
||  @param        p_tab_caption - collection with caption information
||  @param        p_tab_columns - collection with column settings
||  @param        p_format - Formatting of the cells in new row according to constants
||                  in package header or user defines formats.
||  @param        p_height - Row height in pt
||  @param        p_protected - indicates whether or not cell protection is in effect.
||                  When the worksheet is unprotected, cell-level protection has no effect
||  @param        p_beginNewRow - Begin new data row after opening the worksheet
||  @param        p_rec_printSetup - format for printing, only necessary when repeating columns/rows
||                  or a print area is defined
*/
PROCEDURE newWorksheet
    (
     p_fileHandle           IN utl_file.FILE_TYPE
    ,p_sheetname            IN VARCHAR2
    ,p_tab_caption          IN t_tab_caption := g_tab_caption
    ,p_tab_columns          IN t_tab_columns := g_tab_columns
    ,p_format               IN VARCHAR2 := NULL
    ,p_height               IN PLS_INTEGER := NULL
    ,p_protected            IN BOOLEAN  := NULL
    ,p_beginNewRow          IN BOOLEAN  := TRUE
    ,p_rec_printSetup       IN t_rec_printSetup := g_rec_printSetup
    )
IS
     v_clob                  CLOB;
BEGIN
    pld('newWorksheet File');

    dbms_lob.createTemporary(v_clob,TRUE);

    writeNewWorksheet(
         v_clob
        ,p_sheetname
        ,p_tab_caption
        ,p_tab_columns
        ,p_format
        ,p_height
        ,p_protected
        ,p_beginNewRow
        ,p_rec_printSetup
        );

    if g_apps ='N' then      
      put_data(p_fileHandle, v_clob);
    else
      put_data(fnd_file.output, v_clob);
    end if;  

    dbms_lob.freeTemporary(v_clob);

END newWorksheet;

/**
||  @Name         newWorksheet
||  @Description  open a new worksheet and open first data row
||  @param        p_file - CLOB
||  @param        p_sheetname - name of the first worksheet.
||                  This name has to be unique within the file
||  @param        p_tab_caption - collection with caption information
||  @param        p_tab_columns - collection with column settings
||  @param        p_format - Formatting of the cells in new row according to constants
||                  in package header or user defines formats.
||  @param        p_height - Row height in pt
||  @param        p_protected - indicates whether or not cell protection is in effect.
||                  When the worksheet is unprotected, cell-level protection has no effect
||  @param        p_beginNewRow - Begin new data row after opening the worksheet
||  @param        p_rec_printSetup - format for printing, only necessary when repeating columns/rows
||                  or a print area is defined
*/
PROCEDURE newWorksheet
    (
     p_file                 IN OUT NOCOPY CLOB
    ,p_sheetname            IN VARCHAR2
    ,p_tab_caption          IN t_tab_caption := g_tab_caption
    ,p_tab_columns          IN t_tab_columns := g_tab_columns
    ,p_format               IN VARCHAR2 := NULL
    ,p_height               IN PLS_INTEGER := NULL
    ,p_protected            IN BOOLEAN  := NULL
    ,p_beginNewRow          IN BOOLEAN  := TRUE
    ,p_rec_printSetup       IN t_rec_printSetup := g_rec_printSetup
    )
IS

BEGIN
    pld('newWorksheet CLOB');

    writeNewWorksheet(
         p_file
        ,p_sheetname
        ,p_tab_caption
        ,p_tab_columns
        ,p_format
        ,p_height
        ,p_protected
        ,p_beginNewRow
        ,p_rec_printSetup
        );
END newWorksheet;
/*-----------------------------------------------------------------------------
||  Name:         closeFile
||  Description:  close last data row and close file
||  Parameter:    p_fileHandle - file handle from 'createNewFile'
-----------------------------------------------------------------------------*/
PROCEDURE closeFile
    (
     p_fileHandle           IN utl_file.FILE_TYPE
    )
IS
     v_clob                  clob;
BEGIN
    pld('closeFile File');

    dbms_lob.createTemporary(v_clob,TRUE);

    put_line(v_clob,'</Workbook>');
    
    if g_apps ='N' then      
      put_data(p_fileHandle, v_clob);
    else
      put_data(fnd_file.output, v_clob);
    end if;  

    dbms_lob.freeTemporary(v_clob);

    fclose(p_fileHandle);

END closeFile;

PROCEDURE closeFile
    (
     p_file                 IN OUT NOCOPY CLOB
    )
IS

BEGIN
    pld('closeFile CLOB');

    put_line(p_file,'</Workbook>');

END closeFile;

PROCEDURE writeSumCols
    (
     p_clob                 IN OUT NOCOPY CLOB
    ,p_sumColumns           IN t_tab_query
    ,p_row_cnt              IN PLS_INTEGER
    )
IS
BEGIN
    pld('writeSumCols File');
    pld('. p_sumColumns.COUNT '||p_sumColumns.COUNT);

    IF p_sumColumns.COUNT > 0 THEN
        FOR i IN 1 .. g_desc_t.COUNT LOOP
            IF p_sumColumns.exists(i)
              AND UPPER(p_sumColumns(i)) = 'Y'
            THEN
                writeData(
                     p_clob
                    ,0
                    ,c_unformattedSum
                    ,'Col Sum'
                    ,'=SUM(R[-'||TO_CHAR(p_row_cnt + 1)||']C:R[-1]C)'
                    );
            ELSE
                writeData(p_clob,' ');
            END IF;
        END LOOP;
    END IF;
END writeSumCols;

PROCEDURE writequery
    (
     p_cursor               IN INTEGER
    ,p_clob                 IN OUT NOCOPY CLOB
    ,p_sheetname            IN VARCHAR2
    ,p_sumColumns           IN t_tab_query DEFAULT t_tab_query()
    ,p_maxRows              IN NUMBER       DEFAULT 64000
    ,p_showNullAs           IN VARCHAR2     DEFAULT NULL
    ,p_titles               IN t_tab_query DEFAULT t_tab_query()
    )
IS
    tab_columns             t_tab_columns;
    tab_caption             t_tab_caption;
    tab_conditionalFormats  t_tab_conditionalFormats;

    v_page                  PLS_INTEGER := 2;

    l_row_cnt               PLS_INTEGER := 0;
    l_col_cnt               PLS_INTEGER;
    l_status                PLS_INTEGER;
    g_cvalue                VARCHAR2(32767);

    v_nls_date_format       VARCHAR2(50);
    v_my_date_format        VARCHAR2(30) := 'dd.mm.yyyy hh24:mi:ss';

BEGIN
    -- Set the Date format. Otherwise the result depends on initial parameter settings
    -- Errors might occure when i.e. date format is set to dd.mm.rr

    SELECT  value
    INTO    v_nls_date_format
    FROM    nls_session_parameters
    WHERE   UPPER(parameter) = 'NLS_DATE_FORMAT';

    EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT = '''||v_my_date_format||'''';


    -- read column properties
    dbms_sql.describe_columns( p_cursor, l_col_cnt, g_desc_t );
   --
    FOR i IN 1 .. g_desc_t.COUNT LOOP
        dbms_sql.define_column( p_cursor, i, g_cvalue, 32765);
    END LOOP;

    -- write captions and column width
    FOR i IN 1 .. g_desc_t.COUNT LOOP
        tab_columns(i).cWidth         := g_desc_t(i).col_name_len * 8;--
        tab_columns(i).cAutowidth     := TRUE;

        BEGIN
            tab_caption(i).title     := p_titles(i);
        EXCEPTION
            WHEN OTHERS THEN
                tab_caption(i).title := g_desc_t(i).col_name;
        END;
    END LOOP;

    -- open first worksheet
    xml_spreadsheet.newWorksheet(
             p_clob
            ,p_sheetname
            ,tab_caption
            ,tab_columns
            );

    l_status := dbms_sql.execute( p_cursor );

    LOOP
        EXIT WHEN dbms_sql.fetch_rows( p_cursor ) <= 0;
        l_row_cnt := l_row_cnt + 1;

        FOR i IN 1 .. g_desc_t.COUNT LOOP
            dbms_sql.column_value( p_cursor, i, g_cvalue );
            g_cvalue := REPLACE( g_cvalue,CHR(10), '<br>' );
            IF g_desc_t(i).col_type = 2 THEN
                writeData(p_clob,TO_NUMBER(g_cvalue),c_unformatted);
            ELSIF g_desc_t(i).col_type = 12 THEN
                writeData(p_clob,TO_DATE(g_cvalue),c_date);
            ELSE
                writeData(p_clob,NVL(g_cvalue,p_showNullAs));
            END IF;
        END LOOP;

        IF MOD(l_row_cnt,p_maxRows) = 0 THEN
            writeSumCols(
                 p_clob
                ,p_sumColumns
                ,l_row_cnt
                );
            closeWorksheet(
                 p_clob
                ,1
                ,0
                ,tab_caption
                --,TRUE
                --,tab_conditionalFormats
                );
            newWorksheet(
                 p_clob
                ,p_sheetname||'-'||TO_CHAR(v_page)
                ,tab_caption
                ,tab_columns
                );
            v_page      := v_page + 1;
            l_row_cnt   := 0;
        ELSE
            newDataRow(p_clob);
        END IF;
    END LOOP;

    writeSumCols(
         p_clob
        ,p_sumColumns
        ,l_row_cnt
        );
    closeWorksheet(
         p_clob
        ,1
        ,0
        ,tab_caption
        --,TRUE
        --,tab_conditionalFormats
        );

    EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT = '''||v_nls_date_format||'''';

END writequery;

/*-----------------------------------------------------------------------------
||  Name:         query
||  Description:  write the output of the cursor  into an excelformat file
||                idea taken from package owa_silk from Tom Kyte
||  Parameter:    p_cursor - cursor
||                p_path - directory path - DIRECTORY_NAME from DB
||                p_filename - file name
||                p_sumColumns - list of columns to be summed
||                p_maxRows - maximum rows to be written on one worksheet Default 64000
||                p_showNullAs - how to disply NULLS
||                p_titles - list of column captions
||  @param        p_encoding - Character encoding like UTF-8, UTF-16. DEFAULT windows-1252
-----------------------------------------------------------------------------*/
PROCEDURE query
    (
     p_cursor               IN INTEGER
    ,p_path                 IN VARCHAR2     DEFAULT NULL
    ,p_filename             IN VARCHAR2     DEFAULT NULL
    ,p_sumColumns           IN t_tab_query DEFAULT t_tab_query()
    ,p_maxRows              IN NUMBER       DEFAULT 64000
    ,p_showNullAs           IN VARCHAR2     DEFAULT NULL
    ,p_titles               IN t_tab_query DEFAULT t_tab_query()
    ,p_encoding             IN VARCHAR2     DEFAULT 'UTF-8'
    )
IS
--
    v_fileHandle            utl_file.FILE_TYPE;
    v_AppsfileHandle        NUMBER;
    v_filename              VARCHAR2(200);
    v_logname               VARCHAR2(200);
    v_clob                  clob;
BEGIN

    if g_apps ='N' then 
    -- Open file
    v_filename     := NVL(      p_filename
                                ,'query_'||
                                 LOWER(SYS_CONTEXT ('USERENV', 'OS_USER'))||'_'||
                                 TO_CHAR(SYSDATE,'YYYYMMDD_HH24MISS')||
                                 '.xls'
                                 );
    
    v_fileHandle   := createNewFile(p_path,v_filename,g_tab_customStyles,g_rec_customStyles,p_encoding);
    else     
     v_AppsfileHandle := createNewFile_Apps(g_tab_customStyles,g_rec_customStyles,p_encoding);
     fnd_file.GET_NAMES(v_logname,v_filename);
    end if;
    
    dbms_lob.createTemporary(v_clob,TRUE);

    writequery(
         p_cursor
        ,v_clob
        ,'query'
        ,p_sumColumns
        ,p_maxRows
        ,p_showNullAs
        ,p_titles
        );

    if g_apps ='N' then      
      put_data(v_fileHandle, v_clob);
    else
      put_data(v_AppsfileHandle, v_clob);
    end if;  

    dbms_lob.freeTemporary(v_clob);

    closeFile(v_fileHandle);

END query;

/*-----------------------------------------------------------------------------
||  Name:         build_cursor
||  Description:  build a cursor from a SELECT
||  Parameter:    p_query - SELECT string
||                p_parm_names - list of parameter names
||                p_parm_values - list of parameter values
-----------------------------------------------------------------------------*/
FUNCTION build_cursor
    (
     p_query                IN VARCHAR2
    ,p_parm_names           IN t_tab_query
    ,p_parm_values          IN t_tab_query
    )
    RETURN INTEGER
IS
    cur_c                   INTEGER := dbms_sql.open_cursor;
    i                       PLS_INTEGER := 1;
BEGIN
    pld('build_cursor');

    dbms_sql.parse (cur_c, p_query, dbms_sql.native);
    LOOP
        dbms_sql.bind_variable( cur_c, p_parm_names(i), p_parm_values(i) );
        i := i + 1;
    END LOOP;

    RETURN cur_c;

EXCEPTION
    WHEN OTHERS THEN
        RETURN cur_c;
END build_cursor;

/*-----------------------------------------------------------------------------
||  Name:         query
||  Description:  write the output of the query into an excelformat file
||                idea taken from package owa_silk from Tom Kyte
||  Parameter:    p_query - SELECT
||                p_path - DIRECTORY_NAME from DB
||                p_filename - file name
||                p_parm_names - list of parameter names
||                p_parm_values - list of parameter values
||                p_sumColumns - list of columns to be summed
||                p_maxRows - maximum rows to be written on one worksheet Default 64000
||                p_showNullAs - how to disply NULLS
||                p_titles - list of column captions
||  @param        p_encoding - Character encoding like UTF-8, UTF-16. DEFAULT windows-1252
-----------------------------------------------------------------------------*/
PROCEDURE query
    (
     p_query                IN VARCHAR2
    ,p_path                 IN VARCHAR2     DEFAULT NULL
    ,p_filename             IN VARCHAR2     DEFAULT NULL
    ,p_parm_names           IN t_tab_query DEFAULT t_tab_query()
    ,p_parm_values          IN t_tab_query DEFAULT t_tab_query()
    ,p_sumColumns           IN t_tab_query DEFAULT t_tab_query()
    ,p_maxRows              IN NUMBER       DEFAULT 64000
    ,p_showNullAs           IN VARCHAR2     DEFAULT NULL
    ,p_titles               IN t_tab_query DEFAULT t_tab_query()
    ,p_encoding             IN VARCHAR2     DEFAULT 'UTF-8'
    )
IS
BEGIN
    query( build_cursor(
                     p_query
                    ,p_parm_names
                    ,p_parm_values
                    )
            ,p_path
            ,p_filename
            ,p_sumColumns
            ,p_maxRows
            ,p_showNullAs
            ,p_titles
            ,p_encoding
            );
END query;

/*-----------------------------------------------------------------------------
||  Name:         query
||  Description:  write the output of the cursor  into an excelformat file
||                idea taken from package owa_silk from Tom Kyte
||                  next query into a file opend with FUNCTION query
||  Parameter:    p_cursor - cursor
||                p_fileHandle - file handle from FUNCTION 'query'
||                p_sheetname - name of the current worksheet.
||                  This name has to be unique within the file
||                p_sumColumns - list of columns to be summed
||                p_maxRows - maximum rows to be written on one worksheet Default 64000
||                p_showNullAs - how to disply NULLS
||                p_titles - list of column captions
||                p_close - should the file be closed after the query
||  @param        p_encoding - Character encoding like UTF-8, UTF-16. DEFAULT windows-1252
-----------------------------------------------------------------------------*/
FUNCTION query
    (
     p_cursor               IN INTEGER
    ,p_path                 IN VARCHAR2     DEFAULT NULL
    ,p_filename             IN VARCHAR2     DEFAULT NULL
    ,p_sheetname            IN VARCHAR2
    ,p_sumColumns           IN t_tab_query DEFAULT t_tab_query()
    ,p_maxRows              IN NUMBER       DEFAULT 64000
    ,p_showNullAs           IN VARCHAR2     DEFAULT NULL
    ,p_titles               IN t_tab_query DEFAULT t_tab_query()
    ,p_close                IN BOOLEAN      DEFAULT TRUE
    ,p_encoding             IN VARCHAR2     DEFAULT 'UTF-8'
    )
    RETURN utl_file.FILE_TYPE
IS
    v_fileHandle            utl_file.FILE_TYPE;
    v_AppsfileHandle        number;
    v_filename              VARCHAR2(200);
    v_logname              VARCHAR2(200);
    v_clob                  clob;
BEGIN
    if g_apps ='N' then  
        -- Open file
     v_filename     := NVL(      p_filename
                                ,'query_'||
                                 LOWER(SYS_CONTEXT ('USERENV', 'OS_USER'))||'_'||
                                 TO_CHAR(SYSDATE,'YYYYMMDD_HH24MISS')||
                                 '.xls'
                                 );

     v_fileHandle   := createNewFile(p_path,v_filename,g_tab_customStyles,g_rec_customStyles,p_encoding);
    else 
     v_AppsfileHandle := createNewFile_Apps(g_tab_customStyles,g_rec_customStyles,p_encoding);
     fnd_file.GET_NAMES(v_logname,v_filename);
    end if;
    dbms_lob.createTemporary(v_clob,TRUE);

    writequery(
         p_cursor
        ,v_clob
        ,p_sheetname
        ,p_sumColumns
        ,p_maxRows
        ,p_showNullAs
        ,p_titles
        );

    if g_apps ='N' then      
      put_data(v_fileHandle, v_clob);
    else
      put_data(v_AppsfileHandle, v_clob);
    end if;  

    dbms_lob.freeTemporary(v_clob);

    IF p_close THEN
        closeFile(v_fileHandle);
    END IF;

    RETURN v_fileHandle;

END query;

/*-----------------------------------------------------------------------------
||  Name:         query
||  Description:  write the output of the query into an excelformat file
||                idea taken from package owa_silk from Tom Kyte
||  Parameter:    p_query - SELECT
||                p_path - DIRECTORY_NAME from DB
||                p_filename - file name
||                p_sheetname - name of the first worksheet.
||                  This name has to be unique within the file
||                p_parm_names - list of parameter names
||                p_parm_values - list of parameter values
||                p_sumColumns - list of columns to be summed
||                p_maxRows - maximum rows to be written on one worksheet Default 64000
||                p_showNullAs - how to disply NULLS
||                p_titles - list of column captions
||                p_close - should the file be closed after the query
||  @param        p_encoding - Character encoding like UTF-8, UTF-16. DEFAULT windows-1252
-----------------------------------------------------------------------------*/
FUNCTION query
    (
     p_query                IN VARCHAR2
    ,p_path                 IN VARCHAR2     DEFAULT NULL
    ,p_filename             IN VARCHAR2     DEFAULT NULL
    ,p_sheetname            IN VARCHAR2
    ,p_parm_names           IN t_tab_query DEFAULT t_tab_query()
    ,p_parm_values          IN t_tab_query DEFAULT t_tab_query()
    ,p_sumColumns           IN t_tab_query DEFAULT t_tab_query()
    ,p_maxRows              IN NUMBER       DEFAULT 64000
    ,p_showNullAs           IN VARCHAR2     DEFAULT NULL
    ,p_titles               IN t_tab_query DEFAULT t_tab_query()
    ,p_close                IN BOOLEAN      DEFAULT TRUE
    ,p_encoding             IN VARCHAR2     DEFAULT 'UTF-8'
    )
    RETURN utl_file.FILE_TYPE
IS
BEGIN
    RETURN query(
                 build_cursor(
                     p_query
                    ,p_parm_names
                    ,p_parm_values
                    )
                ,p_path
                ,p_filename
                ,p_sheetname
                ,p_sumColumns
                ,p_maxRows
                ,p_showNullAs
                ,p_titles
                ,p_close
                ,p_encoding
                );
END query;

/*-----------------------------------------------------------------------------
||  Name:         query
||  Description:  write the output of the cursor  into an excelformat file
||                idea taken from package owa_silk from Tom Kyte
||                  next query into a file opend with FUNCTION query
||  Parameter:    p_cursor - cursor
||                p_fileHandle - file handle from FUNCTION 'query'
||                p_sheetname - name of the current worksheet.
||                  This name has to be unique within the file
||                p_sumColumns - list of columns to be summed
||                p_maxRows - maximum rows to be written on one worksheet Default 64000
||                p_showNullAs - how to disply NULLS
||                p_titles - list of column captions
||                p_close - should the file be closed after the query
-----------------------------------------------------------------------------*/
PROCEDURE query
    (
     p_cursor               IN INTEGER
    ,p_fileHandle           IN utl_file.FILE_TYPE
    ,p_sheetname            IN VARCHAR2
    ,p_sumColumns           IN t_tab_query DEFAULT t_tab_query()
    ,p_maxRows              IN NUMBER       DEFAULT 64000
    ,p_showNullAs           IN VARCHAR2     DEFAULT NULL
    ,p_titles               IN t_tab_query DEFAULT t_tab_query()
    ,p_close                IN BOOLEAN      DEFAULT TRUE
    )
IS
    v_clob                  CLOB;
BEGIN
    dbms_lob.createTemporary(v_clob,TRUE);

    writequery(
         p_cursor
        ,v_clob
        ,p_sheetname
        ,p_sumColumns
        ,p_maxRows
        ,p_showNullAs
        ,p_titles
        );

    if g_apps ='N' then      
      put_data(p_fileHandle, v_clob);
    else
      put_data(fnd_file.output, v_clob);
    end if;  

    dbms_lob.freeTemporary(v_clob);

    IF p_close THEN
        closeFile(p_fileHandle);
    END IF;

END query;

/*-----------------------------------------------------------------------------
||  Name:         query
||  Description:  write the output of the query into an excelformat file
||                idea taken from package owa_silk from Tom Kyte
||                  next query into a file opend with FUNCTION query
||  Parameter:    p_query - SELECT
||                p_fileHandle - file handle from FUNCTION 'query'
||                p_sheetname - name of the current worksheet.
||                  This name has to be unique within the file
||                p_parm_names - list of parameter names
||                p_parm_values - list of parameter values
||                p_sumColumns - list of columns to be summed
||                p_maxRows - maximum rows to be written on one worksheet Default 64000
||                p_showNullAs - how to disply NULLS
||                p_titles - list of column captions
||                p_close - should the file be closed after the query
-----------------------------------------------------------------------------*/
PROCEDURE query
    (
     p_query                IN VARCHAR2
    ,p_fileHandle           IN utl_file.FILE_TYPE
    ,p_sheetname            IN VARCHAR2
    ,p_parm_names           IN t_tab_query DEFAULT t_tab_query()
    ,p_parm_values          IN t_tab_query DEFAULT t_tab_query()
    ,p_sumColumns           IN t_tab_query DEFAULT t_tab_query()
    ,p_maxRows              IN NUMBER       DEFAULT 64000
    ,p_showNullAs           IN VARCHAR2     DEFAULT NULL
    ,p_titles               IN t_tab_query DEFAULT t_tab_query()
    ,p_close                IN BOOLEAN      DEFAULT TRUE
    )
IS
BEGIN
    query( build_cursor(
                     p_query
                    ,p_parm_names
                    ,p_parm_values
                    )
            ,p_fileHandle
            ,p_sheetname
            ,p_sumColumns
            ,p_maxRows
            ,p_showNullAs
            ,p_titles
            ,p_close
            );
END query;

PROCEDURE query
    (
     p_cursor               IN INTEGER
    ,p_file                 IN OUT NOCOPY CLOB
    ,p_sheetname            IN VARCHAR2
    ,p_sumColumns           IN t_tab_query DEFAULT t_tab_query()
    ,p_maxRows              IN NUMBER       DEFAULT 64000
    ,p_showNullAs           IN VARCHAR2     DEFAULT NULL
    ,p_titles               IN t_tab_query DEFAULT t_tab_query()
    ,p_close                IN BOOLEAN      DEFAULT TRUE
    ,p_first                IN BOOLEAN      DEFAULT TRUE
    ,p_encoding             IN VARCHAR2     DEFAULT 'UTF-8'
    )
IS
BEGIN
    IF p_file IS NULL THEN
       dbms_lob.createTemporary(p_file,TRUE);
    END IF;

    IF p_first THEN       
        createNewFile(p_file,g_tab_customStyles,g_rec_customStyles,p_encoding);
    END IF;

    writequery(
         p_cursor
        ,p_file
        ,p_sheetname
        ,p_sumColumns
        ,p_maxRows
        ,p_showNullAs
        ,p_titles
        );

    IF p_close THEN
        closeFile(p_file);
    END IF;

END query;

PROCEDURE query
    (
     p_query                IN VARCHAR2
    ,p_file                 IN OUT NOCOPY CLOB
    ,p_sheetname            IN VARCHAR2
    ,p_parm_names           IN t_tab_query DEFAULT t_tab_query()
    ,p_parm_values          IN t_tab_query DEFAULT t_tab_query()
    ,p_sumColumns           IN t_tab_query DEFAULT t_tab_query()
    ,p_maxRows              IN NUMBER       DEFAULT 64000
    ,p_showNullAs           IN VARCHAR2     DEFAULT NULL
    ,p_titles               IN t_tab_query DEFAULT t_tab_query()
    ,p_close                IN BOOLEAN      DEFAULT TRUE
    ,p_first                IN BOOLEAN      DEFAULT TRUE
    ,p_encoding             IN VARCHAR2     DEFAULT 'UTF-8'
    )
IS
BEGIN
    query( build_cursor(
                     p_query
                    ,p_parm_names
                    ,p_parm_values
                    )
            ,p_file
            ,p_sheetname
            ,p_sumColumns
            ,p_maxRows
            ,p_showNullAs
            ,p_titles
            ,p_close
            ,p_first
            ,p_encoding
            );
END query;

/**
||  @Name         getRelativeCellReference
||  @Description  The reference in formulas regarding other cells has to be
||                  given relative to the current cell. This function gives
||                  the reference in the correct format R[x]C[y]
||  @param        p_rowFrom - Row of current cell
||  @param        p_colFrom - Column of current cell
||  @param        p_rowTo   - Row of target cell
||  @param        p_colTo   - Column of target cell
||  @return       Reference to target cell, format R[x]C[y]
*/
FUNCTION getRelativeCellReference
    (
     p_rowFrom              IN PLS_INTEGER
    ,p_colFrom              IN PLS_INTEGER
    ,p_rowTo                IN PLS_INTEGER
    ,p_colTo                IN PLS_INTEGER
    )
    RETURN VARCHAR2
IS
    v_reference             VARCHAR2(100);
    v_diff                  INTEGER;

BEGIN
    pld('getRelativeCellReference');
    pld('. p_rowFrom '||p_rowFrom);
    pld('. p_colFrom '||p_colFrom);
    pld('. p_rowTo '||p_rowTo);
    pld('. p_colTo '||p_colTo);

    IF   p_colFrom IS NULL
      OR p_rowFrom IS NULL
      OR p_colTo IS NULL
      OR p_rowTo IS NULL
    THEN
        RAISE_APPLICATION_ERROR(-20001,'Cell references must not be NULL');
    ELSIF p_colFrom < 1
      OR p_rowFrom < 1
      OR p_colTo < 1
      OR p_rowTo < 1
    THEN
        RAISE_APPLICATION_ERROR(-20001,'Cell references must not be less than 1');
    END IF;

    v_diff  := p_rowTo - p_rowFrom;

    IF v_diff = 0 THEN
        v_reference := 'R';
    ELSE
        v_reference := 'R['||v_diff||']';
    END IF;

    v_diff  := p_colTo - p_colFrom;

    IF v_diff = 0 THEN
        v_reference := v_reference||'C';
    ELSE
        v_reference := v_reference||'C['||v_diff||']';
    END IF;

    pld('. v_reference '||v_reference);
    RETURN v_reference;

END getRelativeCellReference;
begin
   g_debug :=false;

END xml_spreadsheet;
/
   PROCEDURE gen_xls(p_org_id   IN NUMBER
                    ,p_cust_fm  IN VARCHAR2 DEFAULT NULL
                    ,p_cust_to  IN VARCHAR2 DEFAULT NULL
                    ,p_dept_fm  IN VARCHAR2 DEFAULT NULL
                    ,p_dept_to  IN VARCHAR2 DEFAULT NULL
                    ,p_sales_fm IN VARCHAR2 DEFAULT NULL
                    ,p_sales_to IN VARCHAR2 DEFAULT NULL)
   AS
      v_percent NUMBER; -- 計算百分比
      --XLS
      v_filehandle UTL_FILE.file_type;
      v_appsfilehandle NUMBER;
      tab_columns xml_spreadsheet.t_tab_columns;
      tab_caption xml_spreadsheet.t_tab_caption;
      tab_conditionalformats xml_spreadsheet.t_tab_conditionalformats;
      r_customstyles xml_spreadsheet.t_rec_customstyles;
      r_font xml_spreadsheet.t_rec_font;
      tab_customstyles xml_spreadsheet.t_tab_customstyles;
      x_char NUMBER := 10;
   BEGIN
      -- 自訂格式
      r_customstyles.id := 's50';
      r_font.fcolor := 'red';
      r_customstyles.font := r_font;
      tab_customstyles(12) := r_customstyles;

      -- 建立新檔案
      v_appsfilehandle := xml_spreadsheet.createnewfile_apps(p_tab_customstyles => tab_customstyles
                                                            ,p_encoding => 'UTF-8');
      xml_spreadsheet.g_apps := 'Y';
      tab_columns(1).cwidth := 5 * x_char;
      tab_columns(2).cwidth := 12 * x_char;
      tab_columns(3).cwidth := 5 * x_char;
      tab_columns(4).cwidth := 12 * x_char;
      tab_columns(5).cwidth := 8 * x_char;
      tab_columns(6).cwidth := 6 * x_char;
      tab_columns(7).cwidth := 14 * x_char;
      tab_columns(8).cwidth := 8 * x_char;
      tab_columns(9).cwidth := 8 * x_char;
      tab_columns(10).cwidth := 4 * x_char;
      tab_columns(11).cwidth := 10 * x_char;
      tab_columns(12).cwidth := 6 * x_char;
      tab_columns(13).cwidth := 4 * x_char;
      tab_columns(14).cwidth := 10 * x_char;
      tab_columns(15).cwidth := 10 * x_char;
      tab_columns(16).cwidth := 10 * x_char;
      tab_columns(17).cwidth := 10 * x_char;
      tab_columns(18).cwidth := 10 * x_char;
      tab_columns(19).cwidth := 10 * x_char;
      tab_columns(20).cwidth := 4 * x_char;
      tab_columns(21).cwidth := 6 * x_char;

      tab_caption(1).title := '識別碼';
      tab_caption(2).title := '組織名稱';
      tab_caption(3).title := '客戶編號';
      tab_caption(4).title := '客戶名稱';
      tab_caption(5).title := '付款條件';
      tab_caption(6).title := '業務部門';
      tab_caption(7).title := '業務部門名稱';
      tab_caption(8).title := 'OU';
      tab_caption(9).title := 'BILL_TO';
      tab_caption(10).title := '主要';
      tab_caption(11).title := '業務員';
      tab_caption(12).title := '額度層級';
      tab_caption(13).title := '幣別';
      tab_caption(14).title := '信用額度金額';
      tab_caption(15).title := '未結訂單金額';
      tab_caption(16).title := '待匯入應收金額';
      tab_caption(17).title := '應收帳款金額';
      tab_caption(18).title := '已收未兌現金額';
      tab_caption(19).title := '已使用額度金額';
      tab_caption(20).title := '百分比';
      tab_caption(21).title := '資料時間';

      -- 建立第一分頁 open first worksheet
      xml_spreadsheet.newworksheet(v_filehandle
                                  ,'信用額度總表'
                                  ,tab_caption
                                  ,tab_columns);

      -- 取出指定客戶或組織, 且(1).台幣 (2).指定額度或使用額度<>0
      FOR rr IN (  SELECT x.party_number
                         ,x.party_name
                         ,x.account_number
                         ,x.account_name
                         ,x.ra_term_desc
                         ,x.sales_department
                         ,x.sales_department_desc
                         ,x.ou
                         ,x.bill_to_location
                         ,x.primary_flag
                         ,x.sales
                         ,x.credit_level
                         ,x.currency_code
                         ,x.credit_limit
                         ,x.open_so_amt
                         ,x.ar_iface_amt
                         ,x.open_ar_amt
                         ,x.receipt_amt
                         ,x.credit_used_amt
                         ,TO_CHAR(creation_date
                                 ,'mm/dd hh24:mi')
                             creation
                     FROM dual
                 ORDER BY x.party_number
                         ,x.account_number)
      LOOP
         xml_spreadsheet.writedata(v_filehandle
                                  ,rr.party_number);
         xml_spreadsheet.writedata(v_filehandle
                                  ,rr.party_name);
         xml_spreadsheet.writedata(v_filehandle
                                  ,rr.account_number);
         xml_spreadsheet.writedata(v_filehandle
                                  ,rr.account_name);
         xml_spreadsheet.writedata(v_filehandle
                                  ,rr.ra_term_desc);
         xml_spreadsheet.writedata(v_filehandle
                                  ,rr.sales_department);
         xml_spreadsheet.writedata(v_filehandle
                                  ,rr.sales_department_desc);
         xml_spreadsheet.writedata(v_filehandle
                                  ,rr.ou);
         xml_spreadsheet.writedata(v_filehandle
                                  ,rr.bill_to_location);
         xml_spreadsheet.writedata(v_filehandle
                                  ,rr.primary_flag);
         xml_spreadsheet.writedata(v_filehandle
                                  ,rr.sales);
         xml_spreadsheet.writedata(v_filehandle
                                  ,rr.credit_level);
         xml_spreadsheet.writedata(v_filehandle
                                  ,rr.currency_code);
         xml_spreadsheet.writedata(v_filehandle
                                  ,rr.credit_limit
                                  ,xml_spreadsheet.c_integer);
         xml_spreadsheet.writedata(v_filehandle
                                  ,rr.open_so_amt
                                  ,xml_spreadsheet.c_integer);
         xml_spreadsheet.writedata(v_filehandle
                                  ,rr.ar_iface_amt
                                  ,xml_spreadsheet.c_integer);
         xml_spreadsheet.writedata(v_filehandle
                                  ,rr.open_ar_amt
                                  ,xml_spreadsheet.c_integer);
         xml_spreadsheet.writedata(v_filehandle
                                  ,rr.receipt_amt
                                  ,xml_spreadsheet.c_integer);
         xml_spreadsheet.writedata(v_filehandle
                                  ,rr.credit_used_amt
                                  ,xml_spreadsheet.c_integer);

         IF rr.credit_limit <> 0
         THEN
            v_percent :=   ROUND(rr.credit_used_amt / rr.credit_limit
                                ,2)
                         * 100;
         ELSE
            v_percent := 0;
         END IF;

         IF v_percent >= 80
         THEN
            xml_spreadsheet.writedata(v_filehandle
                                     ,v_percent
                                      || '%'
                                     ,'s50');
         ELSE
            xml_spreadsheet.writedata(v_filehandle
                                     ,v_percent
                                      || '%');
         END IF;

         xml_spreadsheet.writedata(v_filehandle
                                  ,rr.creation);
         xml_spreadsheet.newdatarow(v_filehandle);
      END LOOP;

      -- close worksheet
      xml_spreadsheet.closeworksheet(v_filehandle
                                    ,1
                                    , -- fix first 1 rows in first worksheet when scrolling
                                     0
                                    , -- fix no columns in first worksheet when scrolling
                                     tab_caption
                                    ,TRUE
                                    ,tab_conditionalformats);
      -- Close file
      xml_spreadsheet.closefile(v_filehandle);
   END gen_xls;
